{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"changelog/","title":"CHANGELOG","text":""},{"location":"changelog/#v100-2025-07-25","title":"v1.0.0 (2025-07-25)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"api/reference/","title":"API Index","text":""},{"location":"api/reference/#b","title":"B","text":"<ul> <li>BaseDataSync <code>(Class)</code> in programs.data_sync.data_sync</li> </ul>"},{"location":"api/reference/#c","title":"C","text":"<ul> <li>COMPARISON_OPS <code>(Variable)</code> in devices.status</li> <li>Comparisons <code>(Class)</code> in devices.status</li> </ul>"},{"location":"api/reference/#d","title":"D","text":"<ul> <li>D <code>(Variable)</code> in devices.device</li> <li>DEVICE_API_FACTORY <code>(Variable)</code> in devices.api</li> <li>DEVICE_FACTORY <code>(Variable)</code> in devices.device</li> <li>DEVICE_PATTERN_MAC_ADDRESS <code>(Variable)</code> in devices.devices_func</li> <li>DEVICE_PATTERN_THIRD_PARTY <code>(Variable)</code> in devices.devices_func</li> <li>Device <code>(Class)</code> in devices.device</li> <li>DeviceApi <code>(Class)</code> in devices.api</li> <li>DeviceAvailability <code>(Class)</code> in devices.deviceVariables</li> <li>DeviceManager <code>(Class)</code> in devices.deviceManager</li> <li>DeviceStateObject <code>(Class)</code> in devices.deviceVariables</li> <li>DeviceVariable <code>(Class)</code> in devices.deviceVariables</li> </ul>"},{"location":"api/reference/#e","title":"E","text":"<ul> <li>EpeverInverter <code>(Class)</code> in external_api.epever.epever_devices</li> <li>EpeverVariableObject <code>(Class)</code> in external_api.epever.epever_objects</li> <li>EpeverVariablesConfs <code>(Class)</code> in external_api.epever.epever_objects</li> <li>ErrorVariable <code>(Class)</code> in external_api.epever.epever_objects</li> <li>ErrorVariablesConfig <code>(Class)</code> in devices.status</li> </ul>"},{"location":"api/reference/#f","title":"F","text":"<ul> <li>File <code>(Class)</code> in programs.data_sync.schemas</li> <li>FileInfo <code>(Class)</code> in programs.data_sync.schemas</li> <li>FileTypes <code>(Class)</code> in programs.data_sync.schemas</li> <li>FloatVariable <code>(Class)</code> in programs.data_sync.schemas</li> </ul>"},{"location":"api/reference/#i","title":"I","text":"<ul> <li>INTERFACE_FACTORY <code>(Variable)</code> in devices.interface</li> <li>InfluxDBConfig <code>(Class)</code> in programs.data_sync.data_sync_settings</li> <li>InfluxDataSync <code>(Class)</code> in programs.data_sync.data_sync</li> <li>Interface <code>(Class)</code> in devices.interface</li> </ul>"},{"location":"api/reference/#m","title":"M","text":"<ul> <li>MANUFACTURER <code>(Variable)</code> in devices.devices_func</li> <li>ModbusRtu <code>(Class)</code> in devices.interfaces.modbusRTU</li> </ul>"},{"location":"api/reference/#s","title":"S","text":"<ul> <li>SERIAL_NUMBER <code>(Variable)</code> in devices.devices_func</li> <li>STATUS_FILE_FIELD_NAMES <code>(Variable)</code> in programs.data_sync.data_sync</li> <li>StandardFloatVariable <code>(Class)</code> in external_api.epever.epever_objects</li> <li>StandardFloatVariableSigned <code>(Class)</code> in external_api.epever.epever_objects</li> <li>StandardIntVariable <code>(Class)</code> in external_api.epever.epever_objects</li> <li>StandardIntVariableSigned <code>(Class)</code> in external_api.epever.epever_objects</li> <li>StandardStrVariableMapping <code>(Class)</code> in external_api.epever.epever_objects</li> <li>StartAndEndBit <code>(Class)</code> in external_api.epever.epever_objects</li> <li>Status <code>(Class)</code> in devices.status</li> <li>Status <code>(Class)</code> in programs.data_sync.schemas</li> <li>StatusFlags <code>(Class)</code> in devices.status</li> <li>StatusVariables <code>(Class)</code> in devices.status</li> <li>StringVariable <code>(Class)</code> in programs.data_sync.schemas</li> </ul>"},{"location":"api/reference/#v","title":"V","text":"<ul> <li>VARIABLE_FACTORY <code>(Variable)</code> in external_api.epever.epever_objects</li> <li>VAR_FILE_FIELD_NAMES <code>(Variable)</code> in programs.data_sync.data_sync</li> <li>Variable <code>(Class)</code> in programs.data_sync.schemas</li> <li>VariablesConfs <code>(Class)</code> in devices.deviceVariables</li> <li>Vars <code>(Class)</code> in devices.deviceVariables</li> </ul>"},{"location":"api/reference/#c_1","title":"C","text":"<ul> <li>config <code>(Class)</code> in programs.data_sync.data_sync_settings</li> <li>convert_datetime_to_iso <code>(Function)</code> in devices.status</li> </ul>"},{"location":"api/reference/#g","title":"G","text":"<ul> <li>get_device_api <code>(Function)</code> in devices.api</li> <li>get_device_id <code>(Function)</code> in devices.devices_func</li> <li>get_device_manufacturer <code>(Function)</code> in devices.devices_func</li> <li>get_interface_cls <code>(Function)</code> in devices.interface</li> <li>get_variable_cls <code>(Function)</code> in external_api.epever.epever_objects</li> </ul>"},{"location":"api/reference/#o","title":"O","text":"<ul> <li>oneBitStrVariable <code>(Class)</code> in external_api.epever.epever_objects</li> </ul>"},{"location":"api/reference/#r","title":"R","text":"<ul> <li>register_device <code>(Function)</code> in devices.device</li> <li>register_device_api <code>(Function)</code> in devices.api</li> <li>register_interface <code>(Function)</code> in devices.interface</li> <li>register_variable_objects <code>(Function)</code> in external_api.epever.epever_objects</li> </ul>"},{"location":"api/devices/api/","title":"devices.api","text":""},{"location":"api/devices/api/#classes","title":"Classes","text":""},{"location":"api/devices/api/#deviceapi","title":"DeviceApi","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for device API implementations.</p> <p>Classes implementing this protocol must provide methods to interact with device APIs, specifically for retrieving device variables.</p> Source code in <code>devices/api.py</code> <pre><code>class DeviceApi(Protocol):\n\"\"\"Protocol defining the interface for device API implementations.\n\n    Classes implementing this protocol must provide methods to interact with\n    device APIs, specifically for retrieving device variables.\n    \"\"\"\n\n    def get_vars(self, device_id: str) -&gt; None:\n\"\"\"Retrieve variables for a specific device.\n\n        Args:\n            device_id: The unique identifier of the device.\n\n        Returns:\n            None\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/devices/api/#devices.api.DeviceApi.get_vars","title":"<code>get_vars(device_id: str) -&gt; None</code>","text":"<p>Retrieve variables for a specific device.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>str</code> <p>The unique identifier of the device.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>devices/api.py</code> <pre><code>def get_vars(self, device_id: str) -&gt; None:\n\"\"\"Retrieve variables for a specific device.\n\n    Args:\n        device_id: The unique identifier of the device.\n\n    Returns:\n        None\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/api/#functions","title":"Functions","text":""},{"location":"api/devices/api/#register_device_api","title":"register_device_api","text":"<p>Register a DeviceApi class to the factory registry.</p> <p>This decorator registers a class that implements the DeviceApi protocol to the DEVICE_API_FACTORY dictionary, making it available for retrieval via <code>get_device_api()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <p>The DeviceApi implementation class to register.</p> required <p>Returns:</p> Type Description <p>The class unchanged, allowing it to be used as a decorator.</p> Source code in <code>devices/api.py</code> <pre><code>def register_device_api(cls):\n\"\"\"Register a DeviceApi class to the factory registry.\n\n    This decorator registers a class that implements the DeviceApi protocol\n    to the DEVICE_API_FACTORY dictionary, making it available for retrieval\n    via `get_device_api()`.\n\n    Args:\n        cls: The DeviceApi implementation class to register.\n\n    Returns:\n        The class unchanged, allowing it to be used as a decorator.\n    \"\"\"\n    logger.warning(f\"Registering {cls} to device api factory\")\n    DEVICE_API_FACTORY[cls.__name__] = cls\n    return cls\n</code></pre>"},{"location":"api/devices/api/#get_device_api","title":"get_device_api","text":"<p>Retrieve a DeviceApi class from the factory registry.</p> <p>Parameters:</p> Name Type Description Default <code>api_name</code> <code>str</code> <p>The name of the DeviceApi class to retrieve.</p> required <p>Returns:</p> Type Description <code>DeviceApi | None</code> <p>The DeviceApi class if found, None otherwise. Logs an error</p> <code>DeviceApi | None</code> <p>if the API name is not found in the registry.</p> Source code in <code>devices/api.py</code> <pre><code>def get_device_api(api_name: str) -&gt; \"DeviceApi | None\":\n\"\"\"Retrieve a DeviceApi class from the factory registry.\n\n    Args:\n        api_name: The name of the DeviceApi class to retrieve.\n\n    Returns:\n        The DeviceApi class if found, None otherwise. Logs an error\n        if the API name is not found in the registry.\n    \"\"\"\n    api = DEVICE_API_FACTORY.get(api_name)\n    if not api:\n        logger.error(f\"api {api_name} not found in {DEVICE_API_FACTORY=}\")\n    return api\n</code></pre>"},{"location":"api/devices/api/#variables","title":"Variables","text":""},{"location":"api/devices/api/#devices.api.DEVICE_API_FACTORY","title":"<code>devices.api.DEVICE_API_FACTORY: dict[str, DeviceApi] = {}</code>  <code>module-attribute</code>","text":"<p>Factory registry for DeviceApi implementations.</p> <p>Maps API class names to their corresponding DeviceApi class implementations. This dictionary is populated by the <code>register_device_api</code> decorator.</p>"},{"location":"api/devices/device/","title":"devices.device","text":""},{"location":"api/devices/device/#classes","title":"Classes","text":""},{"location":"api/devices/device/#device","title":"Device","text":"<p>Base class for device implementations.</p> <p>This class provides the core functionality for device communication, variable polling, state management, and data persistence. Subclasses should override <code>_get_vars()</code> to implement device-specific variable retrieval logic.</p> <p>Attributes:</p> Name Type Description <code>DEVICE_MATCH</code> <code>list[str]</code> <p>List of device type identifiers used for factory registration.</p> <code>DEVICE_STATE_OBJECTS</code> <p>List of attribute names that should be included in device state serialization.</p> Source code in <code>devices/device.py</code> <pre><code>class Device:\n\"\"\"Base class for device implementations.\n\n    This class provides the core functionality for device communication,\n    variable polling, state management, and data persistence. Subclasses\n    should override `_get_vars()` to implement device-specific variable\n    retrieval logic.\n\n    Attributes:\n        DEVICE_MATCH: List of device type identifiers used for factory registration.\n        DEVICE_STATE_OBJECTS: List of attribute names that should be included\n            in device state serialization.\n    \"\"\"\n\n    DEVICE_MATCH: list[str] = []\n\"\"\"List of device type identifiers for factory registration.\"\"\"\n\n    DEVICE_STATE_OBJECTS = [\"device_availability\", \"status\", \"vars\"]\n\"\"\"List of attribute names to include in device state serialization.\"\"\"\n\n    def __init__(\n        self,\n        id: str,\n        environment: \"env.Environment\",\n        interface: Interface,\n        device_conf: DeviceConfig,\n        api: api.DeviceApi | None = None,\n    ) -&gt; None:\n\"\"\"Initialize a Device instance.\n\n        Args:\n            id: Unique identifier for the device.\n            environment: Environment instance providing configuration and context.\n            interface: Interface instance for device communication.\n            device_conf: Device configuration object.\n            api: Optional DeviceApi instance for external API interactions.\n        \"\"\"\n        self.id = id\n        self.vars = Vars()\n        self.hanlders: list = []\n\n        self.environment = environment\n        self.interface = interface\n        self.device_conf = device_conf\n        self.api = api() if api else api\n        self._tasks: set[asyncio.Task] = set()\n        self.canceled = False\n        self.device_availability = DeviceAvailability()\n        self.last_get_vars_timestamp: float = 0.0\n        self.active: bool = True\n        self.status = Status(self.device_conf.error_variables_path)\n        self.device_variables_confs: dict[str, VariablesConfs] = {}\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the device.\n\n        Returns:\n            A string containing the class name and key device attributes.\n        \"\"\"\n        params = \", \".join(\n            [\n                f\"id={self.id}\",\n                f\"device_api={self.api}\",\n                f\"vars={self.vars.vars_dict}\",\n                f\"vars_poll_interval={self.poll_interval}\",\n                f\"canceled={self.canceled}\",\n                f\"active={self.active}\",\n            ]\n        )\n\n        return \"\".join([self.__class__.__name__, \"(\", params, \")\"])\n\n    def load_device_variables_confs(self, path) -&gt; dict[str, VariablesConfs]:\n\"\"\"Load device variable configurations from a file.\n\n        Args:\n            path: Path to the configuration file.\n\n        Returns:\n            Dictionary mapping variable names to their configurations.\n        \"\"\"\n        ...\n\n    async def run(self) -&gt; None:\n\"\"\"Start the device's polling loop.\n\n        This method starts the device's polling task and waits for all tasks\n        to complete. The polling loop will run continuously until canceled.\n        \"\"\"\n        logger.info(f\" Entering run for {self.DEVICE_MATCH}\")\n        # t = await self.poll()\n        t = run_task(self.poll())\n        self._tasks.add(t)\n        await asyncio.gather(*self._tasks)\n\n        logger.debug(f\"Exiting run for {self.id}\")\n\n    async def cancel(self) -&gt; None:\n\"\"\"Cancel all running tasks for this device.\n\n        Sets the canceled flag and cancels all async tasks associated with\n        this device, then waits for them to complete.\n        \"\"\"\n        self.canceled = True\n        for task in self._tasks:\n            logger.debug(f\"Canceling task {task}\")\n            task.cancel()\n\n        if self._tasks:\n            await asyncio.gather(*self._tasks, return_exceptions=True)\n        logger.info(f\"Cancel finished for {self.id}\")\n\n    @property\n    def poll_interval(self) -&gt; int:\n\"\"\"Get the polling interval in seconds.\n\n        Returns:\n            Poll interval for active devices, or the failure poll interval\n            for inactive devices.\n        \"\"\"\n        if self.active:\n            return self.environment.config.all_devices.poll_interval\n        else:\n            return self.environment.config.all_devices.poll_interval_on_failure\n\n    def get_device_id(self) -&gt; str:\n\"\"\"Extract the device ID from the full device identifier.\n\n        Returns:\n            The device ID component of the device identifier.\n        \"\"\"\n        device_id = get_device_id(self.id)\n        return device_id\n\n    @loop_coro(\"poll_interval\")\n    async def poll(self) -&gt; None:\n\"\"\"Poll the device for variables and process the results.\n\n        This method is called periodically to retrieve device variables,\n        save them to disk, check for status updates, and trigger handlers\n        if status changes occur. The polling interval is controlled by the\n        `poll_interval` property.\n        \"\"\"\n        logger.info(f\"In get vars for {self.id}\")\n        try:\n            timestamp = datetime.now()\n            vars = await self.get_vars(timestamp)\n            if vars:\n                self.save_vars(vars, timestamp)\n                updated_status, triggered_vars = self.status.parse_vars(vars, timestamp)\n\n                # triggered_vars needs to be ran after normal vars to make sure vars are not written twice\n                if updated_status and triggered_vars:\n                    for handler in self.handlers:\n                        if asyncio.iscoroutinefunction(handler):\n                            await handler(updated_status, self)\n                        else:\n                            handler(updated_status, self)\n                    self.save_updated_status(updated_status, timestamp)\n                    self.save_vars(triggered_vars, timestamp, triggered_vars=True)\n\n            self.save_state()\n\n        except Exception as e:\n            logger.exception(f\"Failed in get vars poll for {self.id}: {e}\")\n\n    async def _get_vars(\n        self, timestamp: datetime\n    ) -&gt; Optional[dict[str, DeviceVariable]]:\n\"\"\"Retrieve device variables from the device.\n\n        This method should be overridden by subclasses to implement\n        device-specific variable retrieval logic.\n\n        Args:\n            timestamp: Timestamp to associate with the retrieved variables.\n\n        Returns:\n            Dictionary of device variables, or None if retrieval failed.\n        \"\"\"\n        logger.debug(f\"Get vars not implemented for {self.__class__.__name__}\")\n        return None\n\n    async def get_vars(\n        self, timestamp: datetime\n    ) -&gt; Optional[dict[str, DeviceVariable]]:\n\"\"\"Retrieve device variables and update availability tracking.\n\n        This method calls `_get_vars()` and tracks device uptime/downtime.\n        If variables are not received for longer than the deactivate timer,\n        the device is marked as inactive.\n\n        Args:\n            timestamp: Timestamp to associate with the retrieved variables.\n\n        Returns:\n            Dictionary of device variables, or None if retrieval failed.\n        \"\"\"\n        vars = await self._get_vars(timestamp)\n        ts = time.time()\n        delta_t = (\n            ts - self.last_get_vars_timestamp if self.last_get_vars_timestamp &gt; 0 else 0\n        )\n        old_ts = self.last_get_vars_timestamp\n        self.last_get_vars_timestamp = ts\n\n        if not vars:\n            self.device_availability.downtime += delta_t\n            if (\n                old_ts\n                and (ts - old_ts) &gt; self.environment.config.all_devices.deactivate_timer\n            ):\n                logger.warning(\n                    f\"Device deactivating with no vars for {ts - old_ts} seconds: {self}\"\n                )\n                self.active = False\n            return vars\n\n        # incliment the uptime by the difference between the new timestamp and the old timestamp each time the vars are recieved succefully\n        self.device_availability.uptime += delta_t\n        self.active = True\n        return vars\n\n    def get_vars_to_save(\n        self, vars: dict[str, DeviceVariable], timestamp: datetime, triggered_vars: bool\n    ) -&gt; dict[str, DeviceVariable]:\n\"\"\"Determine which variables should be saved to disk.\n\n        Filters variables based on save intervals, change thresholds, and\n        whether they are newly seen or have changed significantly.\n\n        Args:\n            vars: Dictionary of device variables to evaluate.\n            timestamp: Current timestamp for comparison.\n            triggered_vars: Whether these are status-triggered variables.\n\n        Returns:\n            Dictionary of variables that should be saved, sorted by key.\n        \"\"\"\n        vars_to_save = {}\n        for k, v in vars.items():\n            old_v = self.vars.vars_dict.get(k)\n\n            if not old_v:\n                v.last_saving_timestamp = timestamp\n                vars_to_save[k] = v\n                continue\n\n            if v._variable_confs.save_interval == \"never\":\n                continue\n\n            v.last_saving_timestamp = old_v.last_saving_timestamp\n            if (\n                triggered_vars\n                and old_v.last_saving_timestamp != timestamp\n                or timestamp - old_v.last_saving_timestamp\n                &gt; timedelta(seconds=timeparse(v._variable_confs.save_interval))\n                or v.raw_data - old_v.raw_data &gt; v._variable_confs.save_change_threshold\n            ):\n                v.last_saving_timestamp = timestamp\n                vars_to_save[k] = v\n\n        if not triggered_vars:\n            self.vars.vars_dict = vars\n        return dict(sorted(vars_to_save.items()))\n\n    def save_updated_status(\n        self, updated_status: list[StatusVariables], timestamp: datetime\n    ) -&gt; None:\n\"\"\"Save updated status variables to disk.\n\n        Writes status changes to a CSV file in the device's data directory.\n\n        Args:\n            updated_status: List of status variables that have changed.\n            timestamp: Timestamp to use for the status file.\n        \"\"\"\n        fp = self.create_filepath(timestamp, status=True)\n        results_list = []\n        for status_var in updated_status:\n            status_var_json = status_var.serialize()\n            results_list.append(\n                f\"{status_var_json['timestamp']},{status_var_json['error_name']},{status_var_json['flag']},{status_var_json['description']}\\n\"\n            )\n        with fp.open(\"a\") as f:\n            f.writelines(results_list)\n\n        logger.debug(f\"Saved {self.id} data to {fp}\")\n\n    def save_vars(\n        self, vars: dict[str, DeviceVariable], timestamp: datetime, triggered_vars=False\n    ) -&gt; None:\n\"\"\"Save device variables to disk.\n\n        Writes variables to a CSV file in the device's data directory.\n        Only variables that meet the save criteria (determined by\n        `get_vars_to_save()`) are written.\n\n        Args:\n            vars: Dictionary of device variables to save.\n            timestamp: Timestamp to use for the data file.\n            triggered_vars: Whether these are status-triggered variables.\n        \"\"\"\n        fp = self.create_filepath(timestamp)\n        vars_to_save = self.get_vars_to_save(vars, timestamp, triggered_vars)\n\n        if not vars_to_save:\n            logger.info(\"no vars were saved to disk\")\n            return None\n\n        results_list = []\n        for val_obj in vars_to_save.values():\n            var_json = val_obj.serialize()\n            results_list.append(\n                f\"{var_json['timestamp']},{var_json['variable_name']},{var_json['raw_data']},{var_json['unit']},{var_json['processed_data']}\\n\"\n            )\n\n        with fp.open(\"a\") as f:\n            f.writelines(results_list)\n\n        logger.debug(f\"Saved {self.id} data to {fp}\")\n\n    def get_variable(self, variable_name: str) -&gt; DeviceVariable | None:\n\"\"\"Retrieve a specific device variable by name.\n\n        Args:\n            variable_name: Name of the variable to retrieve.\n\n        Returns:\n            The DeviceVariable if found, None otherwise.\n        \"\"\"\n        # logger.info(f\"Getting variable {variable_name} for {self.id}: {self.vars}\")\n        var = self.vars.vars_dict.get(variable_name, None)\n        if not var:\n            return None\n        logger.debug(\n            f\"Getting variable {variable_name} for {self.id}: ({var.timestamp.isoformat()}, {var.serialize()})\"\n        )\n        return var\n\n    def create_filepath(self, timestamp: datetime, status=False) -&gt; Path:\n\"\"\"Create the file path for saving device data.\n\n        Constructs a path based on the device manufacturer, device ID, and\n        timestamp. Creates the directory structure if it doesn't exist.\n\n        Args:\n            timestamp: Timestamp to use for the filename.\n            status: If True, creates a status file path; otherwise creates\n                a data file path.\n\n        Returns:\n            Path object pointing to the appropriate file.\n        \"\"\"\n        manufacturer = get_device_manufacturer(self.id)\n        id = get_device_id(self.id)\n        fp = self.environment.config.data_dir / manufacturer / id\n        fp.mkdir(parents=True, exist_ok=True)\n        if not status:\n            return fp / datetime.strftime(timestamp, \"%Y-%m-%d.csv\")\n        return fp / datetime.strftime(timestamp, \"%Y-%m-%d.status.csv\")\n\n    @staticmethod\n    def from_device_conf(\n        id: str,\n        environment: \"env.Environment\",\n        device_conf: DeviceConfig,\n    ) -&gt; \"Device | None\":\n\"\"\"Create a Device instance from device configuration.\n\n        Factory method that selects the appropriate Device subclass based on\n        the device type and initializes it with the provided configuration.\n        Also restores the device's saved state if available.\n\n        Args:\n            id: Unique identifier for the device.\n            environment: Environment instance providing configuration and context.\n            device_conf: Device configuration object.\n\n        Returns:\n            Initialized Device instance, or None if the device type is not\n            registered or initialization fails.\n        \"\"\"\n        device_id = get_device_id(id)\n        try:\n            if not device_id or int(device_id) == 0:\n                return None\n        except ValueError:\n            pass\n\n        device_type = get_device_manufacturer(id)\n        cls = DEVICE_FACTORY.get(device_type)\n\n        if not cls:\n            logger.warning(\n                f\"Device class for {device_type} not found (Current factory: {DEVICE_FACTORY})\"\n            )\n            return None\n        else:\n            d = cls._from_device_conf(id, environment, device_conf)\n            if not d:\n                return None\n\n        d.restore_state()\n        return d\n\n    @classmethod\n    def _from_device_conf(\n        cls, id: str, environment: \"env.Environment\", device_conf: DeviceConfig\n    ) -&gt; \"Device\":\n\"\"\"Create a Device instance from configuration (subclass implementation).\n\n        This method should be implemented by subclasses to handle\n        device-specific initialization logic.\n\n        Args:\n            id: Unique identifier for the device.\n            environment: Environment instance providing configuration and context.\n            device_conf: Device configuration object.\n\n        Returns:\n            Initialized Device instance.\n\n        Raises:\n            NotImplementedError: If called on the base Device class.\n        \"\"\"\n        raise NotImplementedError\n\n    def update_from_device_conf(self, device_conf: DeviceConfig) -&gt; None:\n\"\"\"Update device configuration from a new DeviceConfig object.\n\n        Args:\n            device_conf: New device configuration to apply.\n        \"\"\"\n        ...\n\n    def restore_state(self) -&gt; None:\n\"\"\"Restore device state from disk.\n\n        Loads previously saved device state (availability, status, variables)\n        from the state file if it exists. Called automatically when creating\n        a device via `from_device_conf()`.\n        \"\"\"\n        logger.info(f\"Restoring state for {self.id}\")\n\n        if not self.state_path.exists():\n            logger.info(f\"No state file found for {self.id}\")\n            return\n\n        try:\n            with self.state_path.open() as f:\n                d = json.load(f)\n                logger.debug(f\"State dict for {self.id}: {d}\")\n            self.from_dict(d=d)\n        except:\n            logger.exception(f\"Failed to load variables for {self.id}\")\n\n    def save_state(self) -&gt; None:\n\"\"\"Save device state to disk.\n\n        Persists the current device state (availability, status, variables)\n        to a JSON file. Called automatically during each polling cycle.\n        \"\"\"\n        logger.debug(f\"{self.__class__.__name__} {self.id} - Trying to save state...\")\n        try:\n            d = self.to_dict()\n\n            with self.state_path.open(\"w\") as f:\n                json.dump(d, f)\n\n            logger.debug(f\"Finished saving state! {self.id}: {d}\")\n\n        except Exception as e:\n            logger.error(f\"Unable to save state for {self.id} : {e}\")\n\n    @property\n    def state_path(self) -&gt; Path:\n\"\"\"Get the file path for saving device state.\n\n        Returns:\n            Path object pointing to the device's state file. The directory\n            structure is created if it doesn't exist.\n        \"\"\"\n        p = (\n            self.environment.config.temp_dir\n            / \"devices\"\n            / get_device_manufacturer(self.id)\n        )\n        p.mkdir(parents=True, exist_ok=True)\n\n        return p / get_device_id(self.id).replace(\":\", \"\")\n\n    def to_dict(self) -&gt; dict[str, Any]:\n\"\"\"Serialize device state to a dictionary.\n\n        Creates a JSON-serializable dictionary containing the device ID, type,\n        and all state objects defined in DEVICE_STATE_OBJECTS.\n\n        Returns:\n            Dictionary representation of the device state.\n        \"\"\"\n        d = {\n            \"device_id\": getattr(self, \"id\", None),\n            \"type\": self.__class__.__name__,\n        }\n\n        for key in self.DEVICE_STATE_OBJECTS:\n            val: DeviceStateObject = getattr(self, key, None)\n            if not isinstance(val, DeviceStateObject):\n                logger.info(\n                    f\"{key} is not a proper DeviceStateObject it has not serialize method\"\n                )\n                continue\n            d[key] = val.serialize()\n\n        return d\n\n    def from_dict(self, d: dict[str, Any]) -&gt; None:\n\"\"\"Deserialize device state from a dictionary.\n\n        Restores device availability, status, and variables from a previously\n        serialized dictionary representation.\n\n        Args:\n            d: Dictionary containing serialized device state.\n        \"\"\"\n        self.device_availability.deserialize(d.get(\"device_availability\"))\n        self.status.deserialize(d.get(\"status\"))\n        self.vars.deserialize(d.get(\"vars\"), self.device_variables_confs)\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.DEVICE_MATCH","title":"<code>DEVICE_MATCH: list[str] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of device type identifiers for factory registration.</p>"},{"location":"api/devices/device/#devices.device.Device.DEVICE_STATE_OBJECTS","title":"<code>DEVICE_STATE_OBJECTS = ['device_availability', 'status', 'vars']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of attribute names to include in device state serialization.</p>"},{"location":"api/devices/device/#devices.device.Device.poll_interval","title":"<code>poll_interval: int</code>  <code>property</code>","text":"<p>Get the polling interval in seconds.</p> <p>Returns:</p> Type Description <code>int</code> <p>Poll interval for active devices, or the failure poll interval</p> <code>int</code> <p>for inactive devices.</p>"},{"location":"api/devices/device/#devices.device.Device.state_path","title":"<code>state_path: Path</code>  <code>property</code>","text":"<p>Get the file path for saving device state.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Path object pointing to the device's state file. The directory</p> <code>Path</code> <p>structure is created if it doesn't exist.</p>"},{"location":"api/devices/device/#devices.device.Device.__init__","title":"<code>__init__(id: str, environment: env.Environment, interface: Interface, device_conf: DeviceConfig, api: api.DeviceApi | None = None) -&gt; None</code>","text":"<p>Initialize a Device instance.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the device.</p> required <code>environment</code> <code>Environment</code> <p>Environment instance providing configuration and context.</p> required <code>interface</code> <code>Interface</code> <p>Interface instance for device communication.</p> required <code>device_conf</code> <code>DeviceConfig</code> <p>Device configuration object.</p> required <code>api</code> <code>DeviceApi | None</code> <p>Optional DeviceApi instance for external API interactions.</p> <code>None</code> Source code in <code>devices/device.py</code> <pre><code>def __init__(\n    self,\n    id: str,\n    environment: \"env.Environment\",\n    interface: Interface,\n    device_conf: DeviceConfig,\n    api: api.DeviceApi | None = None,\n) -&gt; None:\n\"\"\"Initialize a Device instance.\n\n    Args:\n        id: Unique identifier for the device.\n        environment: Environment instance providing configuration and context.\n        interface: Interface instance for device communication.\n        device_conf: Device configuration object.\n        api: Optional DeviceApi instance for external API interactions.\n    \"\"\"\n    self.id = id\n    self.vars = Vars()\n    self.hanlders: list = []\n\n    self.environment = environment\n    self.interface = interface\n    self.device_conf = device_conf\n    self.api = api() if api else api\n    self._tasks: set[asyncio.Task] = set()\n    self.canceled = False\n    self.device_availability = DeviceAvailability()\n    self.last_get_vars_timestamp: float = 0.0\n    self.active: bool = True\n    self.status = Status(self.device_conf.error_variables_path)\n    self.device_variables_confs: dict[str, VariablesConfs] = {}\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a string representation of the device.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the class name and key device attributes.</p> Source code in <code>devices/device.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the device.\n\n    Returns:\n        A string containing the class name and key device attributes.\n    \"\"\"\n    params = \", \".join(\n        [\n            f\"id={self.id}\",\n            f\"device_api={self.api}\",\n            f\"vars={self.vars.vars_dict}\",\n            f\"vars_poll_interval={self.poll_interval}\",\n            f\"canceled={self.canceled}\",\n            f\"active={self.active}\",\n        ]\n    )\n\n    return \"\".join([self.__class__.__name__, \"(\", params, \")\"])\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.cancel","title":"<code>cancel() -&gt; None</code>  <code>async</code>","text":"<p>Cancel all running tasks for this device.</p> <p>Sets the canceled flag and cancels all async tasks associated with this device, then waits for them to complete.</p> Source code in <code>devices/device.py</code> <pre><code>async def cancel(self) -&gt; None:\n\"\"\"Cancel all running tasks for this device.\n\n    Sets the canceled flag and cancels all async tasks associated with\n    this device, then waits for them to complete.\n    \"\"\"\n    self.canceled = True\n    for task in self._tasks:\n        logger.debug(f\"Canceling task {task}\")\n        task.cancel()\n\n    if self._tasks:\n        await asyncio.gather(*self._tasks, return_exceptions=True)\n    logger.info(f\"Cancel finished for {self.id}\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.create_filepath","title":"<code>create_filepath(timestamp: datetime, status=False) -&gt; Path</code>","text":"<p>Create the file path for saving device data.</p> <p>Constructs a path based on the device manufacturer, device ID, and timestamp. Creates the directory structure if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>datetime</code> <p>Timestamp to use for the filename.</p> required <code>status</code> <p>If True, creates a status file path; otherwise creates a data file path.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path object pointing to the appropriate file.</p> Source code in <code>devices/device.py</code> <pre><code>def create_filepath(self, timestamp: datetime, status=False) -&gt; Path:\n\"\"\"Create the file path for saving device data.\n\n    Constructs a path based on the device manufacturer, device ID, and\n    timestamp. Creates the directory structure if it doesn't exist.\n\n    Args:\n        timestamp: Timestamp to use for the filename.\n        status: If True, creates a status file path; otherwise creates\n            a data file path.\n\n    Returns:\n        Path object pointing to the appropriate file.\n    \"\"\"\n    manufacturer = get_device_manufacturer(self.id)\n    id = get_device_id(self.id)\n    fp = self.environment.config.data_dir / manufacturer / id\n    fp.mkdir(parents=True, exist_ok=True)\n    if not status:\n        return fp / datetime.strftime(timestamp, \"%Y-%m-%d.csv\")\n    return fp / datetime.strftime(timestamp, \"%Y-%m-%d.status.csv\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.from_device_conf","title":"<code>from_device_conf(id: str, environment: env.Environment, device_conf: DeviceConfig) -&gt; Device | None</code>  <code>staticmethod</code>","text":"<p>Create a Device instance from device configuration.</p> <p>Factory method that selects the appropriate Device subclass based on the device type and initializes it with the provided configuration. Also restores the device's saved state if available.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>Unique identifier for the device.</p> required <code>environment</code> <code>Environment</code> <p>Environment instance providing configuration and context.</p> required <code>device_conf</code> <code>DeviceConfig</code> <p>Device configuration object.</p> required <p>Returns:</p> Type Description <code>Device | None</code> <p>Initialized Device instance, or None if the device type is not</p> <code>Device | None</code> <p>registered or initialization fails.</p> Source code in <code>devices/device.py</code> <pre><code>@staticmethod\ndef from_device_conf(\n    id: str,\n    environment: \"env.Environment\",\n    device_conf: DeviceConfig,\n) -&gt; \"Device | None\":\n\"\"\"Create a Device instance from device configuration.\n\n    Factory method that selects the appropriate Device subclass based on\n    the device type and initializes it with the provided configuration.\n    Also restores the device's saved state if available.\n\n    Args:\n        id: Unique identifier for the device.\n        environment: Environment instance providing configuration and context.\n        device_conf: Device configuration object.\n\n    Returns:\n        Initialized Device instance, or None if the device type is not\n        registered or initialization fails.\n    \"\"\"\n    device_id = get_device_id(id)\n    try:\n        if not device_id or int(device_id) == 0:\n            return None\n    except ValueError:\n        pass\n\n    device_type = get_device_manufacturer(id)\n    cls = DEVICE_FACTORY.get(device_type)\n\n    if not cls:\n        logger.warning(\n            f\"Device class for {device_type} not found (Current factory: {DEVICE_FACTORY})\"\n        )\n        return None\n    else:\n        d = cls._from_device_conf(id, environment, device_conf)\n        if not d:\n            return None\n\n    d.restore_state()\n    return d\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.from_dict","title":"<code>from_dict(d: dict[str, Any]) -&gt; None</code>","text":"<p>Deserialize device state from a dictionary.</p> <p>Restores device availability, status, and variables from a previously serialized dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict[str, Any]</code> <p>Dictionary containing serialized device state.</p> required Source code in <code>devices/device.py</code> <pre><code>def from_dict(self, d: dict[str, Any]) -&gt; None:\n\"\"\"Deserialize device state from a dictionary.\n\n    Restores device availability, status, and variables from a previously\n    serialized dictionary representation.\n\n    Args:\n        d: Dictionary containing serialized device state.\n    \"\"\"\n    self.device_availability.deserialize(d.get(\"device_availability\"))\n    self.status.deserialize(d.get(\"status\"))\n    self.vars.deserialize(d.get(\"vars\"), self.device_variables_confs)\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.get_device_id","title":"<code>get_device_id() -&gt; str</code>","text":"<p>Extract the device ID from the full device identifier.</p> <p>Returns:</p> Type Description <code>str</code> <p>The device ID component of the device identifier.</p> Source code in <code>devices/device.py</code> <pre><code>def get_device_id(self) -&gt; str:\n\"\"\"Extract the device ID from the full device identifier.\n\n    Returns:\n        The device ID component of the device identifier.\n    \"\"\"\n    device_id = get_device_id(self.id)\n    return device_id\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.get_variable","title":"<code>get_variable(variable_name: str) -&gt; DeviceVariable | None</code>","text":"<p>Retrieve a specific device variable by name.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Name of the variable to retrieve.</p> required <p>Returns:</p> Type Description <code>DeviceVariable | None</code> <p>The DeviceVariable if found, None otherwise.</p> Source code in <code>devices/device.py</code> <pre><code>def get_variable(self, variable_name: str) -&gt; DeviceVariable | None:\n\"\"\"Retrieve a specific device variable by name.\n\n    Args:\n        variable_name: Name of the variable to retrieve.\n\n    Returns:\n        The DeviceVariable if found, None otherwise.\n    \"\"\"\n    # logger.info(f\"Getting variable {variable_name} for {self.id}: {self.vars}\")\n    var = self.vars.vars_dict.get(variable_name, None)\n    if not var:\n        return None\n    logger.debug(\n        f\"Getting variable {variable_name} for {self.id}: ({var.timestamp.isoformat()}, {var.serialize()})\"\n    )\n    return var\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.get_vars","title":"<code>get_vars(timestamp: datetime) -&gt; Optional[dict[str, DeviceVariable]]</code>  <code>async</code>","text":"<p>Retrieve device variables and update availability tracking.</p> <p>This method calls <code>_get_vars()</code> and tracks device uptime/downtime. If variables are not received for longer than the deactivate timer, the device is marked as inactive.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>datetime</code> <p>Timestamp to associate with the retrieved variables.</p> required <p>Returns:</p> Type Description <code>Optional[dict[str, DeviceVariable]]</code> <p>Dictionary of device variables, or None if retrieval failed.</p> Source code in <code>devices/device.py</code> <pre><code>async def get_vars(\n    self, timestamp: datetime\n) -&gt; Optional[dict[str, DeviceVariable]]:\n\"\"\"Retrieve device variables and update availability tracking.\n\n    This method calls `_get_vars()` and tracks device uptime/downtime.\n    If variables are not received for longer than the deactivate timer,\n    the device is marked as inactive.\n\n    Args:\n        timestamp: Timestamp to associate with the retrieved variables.\n\n    Returns:\n        Dictionary of device variables, or None if retrieval failed.\n    \"\"\"\n    vars = await self._get_vars(timestamp)\n    ts = time.time()\n    delta_t = (\n        ts - self.last_get_vars_timestamp if self.last_get_vars_timestamp &gt; 0 else 0\n    )\n    old_ts = self.last_get_vars_timestamp\n    self.last_get_vars_timestamp = ts\n\n    if not vars:\n        self.device_availability.downtime += delta_t\n        if (\n            old_ts\n            and (ts - old_ts) &gt; self.environment.config.all_devices.deactivate_timer\n        ):\n            logger.warning(\n                f\"Device deactivating with no vars for {ts - old_ts} seconds: {self}\"\n            )\n            self.active = False\n        return vars\n\n    # incliment the uptime by the difference between the new timestamp and the old timestamp each time the vars are recieved succefully\n    self.device_availability.uptime += delta_t\n    self.active = True\n    return vars\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.get_vars_to_save","title":"<code>get_vars_to_save(vars: dict[str, DeviceVariable], timestamp: datetime, triggered_vars: bool) -&gt; dict[str, DeviceVariable]</code>","text":"<p>Determine which variables should be saved to disk.</p> <p>Filters variables based on save intervals, change thresholds, and whether they are newly seen or have changed significantly.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>dict[str, DeviceVariable]</code> <p>Dictionary of device variables to evaluate.</p> required <code>timestamp</code> <code>datetime</code> <p>Current timestamp for comparison.</p> required <code>triggered_vars</code> <code>bool</code> <p>Whether these are status-triggered variables.</p> required <p>Returns:</p> Type Description <code>dict[str, DeviceVariable]</code> <p>Dictionary of variables that should be saved, sorted by key.</p> Source code in <code>devices/device.py</code> <pre><code>def get_vars_to_save(\n    self, vars: dict[str, DeviceVariable], timestamp: datetime, triggered_vars: bool\n) -&gt; dict[str, DeviceVariable]:\n\"\"\"Determine which variables should be saved to disk.\n\n    Filters variables based on save intervals, change thresholds, and\n    whether they are newly seen or have changed significantly.\n\n    Args:\n        vars: Dictionary of device variables to evaluate.\n        timestamp: Current timestamp for comparison.\n        triggered_vars: Whether these are status-triggered variables.\n\n    Returns:\n        Dictionary of variables that should be saved, sorted by key.\n    \"\"\"\n    vars_to_save = {}\n    for k, v in vars.items():\n        old_v = self.vars.vars_dict.get(k)\n\n        if not old_v:\n            v.last_saving_timestamp = timestamp\n            vars_to_save[k] = v\n            continue\n\n        if v._variable_confs.save_interval == \"never\":\n            continue\n\n        v.last_saving_timestamp = old_v.last_saving_timestamp\n        if (\n            triggered_vars\n            and old_v.last_saving_timestamp != timestamp\n            or timestamp - old_v.last_saving_timestamp\n            &gt; timedelta(seconds=timeparse(v._variable_confs.save_interval))\n            or v.raw_data - old_v.raw_data &gt; v._variable_confs.save_change_threshold\n        ):\n            v.last_saving_timestamp = timestamp\n            vars_to_save[k] = v\n\n    if not triggered_vars:\n        self.vars.vars_dict = vars\n    return dict(sorted(vars_to_save.items()))\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.load_device_variables_confs","title":"<code>load_device_variables_confs(path) -&gt; dict[str, VariablesConfs]</code>","text":"<p>Load device variable configurations from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>Path to the configuration file.</p> required <p>Returns:</p> Type Description <code>dict[str, VariablesConfs]</code> <p>Dictionary mapping variable names to their configurations.</p> Source code in <code>devices/device.py</code> <pre><code>def load_device_variables_confs(self, path) -&gt; dict[str, VariablesConfs]:\n\"\"\"Load device variable configurations from a file.\n\n    Args:\n        path: Path to the configuration file.\n\n    Returns:\n        Dictionary mapping variable names to their configurations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.poll","title":"<code>poll() -&gt; None</code>  <code>async</code>","text":"<p>Poll the device for variables and process the results.</p> <p>This method is called periodically to retrieve device variables, save them to disk, check for status updates, and trigger handlers if status changes occur. The polling interval is controlled by the <code>poll_interval</code> property.</p> Source code in <code>devices/device.py</code> <pre><code>@loop_coro(\"poll_interval\")\nasync def poll(self) -&gt; None:\n\"\"\"Poll the device for variables and process the results.\n\n    This method is called periodically to retrieve device variables,\n    save them to disk, check for status updates, and trigger handlers\n    if status changes occur. The polling interval is controlled by the\n    `poll_interval` property.\n    \"\"\"\n    logger.info(f\"In get vars for {self.id}\")\n    try:\n        timestamp = datetime.now()\n        vars = await self.get_vars(timestamp)\n        if vars:\n            self.save_vars(vars, timestamp)\n            updated_status, triggered_vars = self.status.parse_vars(vars, timestamp)\n\n            # triggered_vars needs to be ran after normal vars to make sure vars are not written twice\n            if updated_status and triggered_vars:\n                for handler in self.handlers:\n                    if asyncio.iscoroutinefunction(handler):\n                        await handler(updated_status, self)\n                    else:\n                        handler(updated_status, self)\n                self.save_updated_status(updated_status, timestamp)\n                self.save_vars(triggered_vars, timestamp, triggered_vars=True)\n\n        self.save_state()\n\n    except Exception as e:\n        logger.exception(f\"Failed in get vars poll for {self.id}: {e}\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.restore_state","title":"<code>restore_state() -&gt; None</code>","text":"<p>Restore device state from disk.</p> <p>Loads previously saved device state (availability, status, variables) from the state file if it exists. Called automatically when creating a device via <code>from_device_conf()</code>.</p> Source code in <code>devices/device.py</code> <pre><code>def restore_state(self) -&gt; None:\n\"\"\"Restore device state from disk.\n\n    Loads previously saved device state (availability, status, variables)\n    from the state file if it exists. Called automatically when creating\n    a device via `from_device_conf()`.\n    \"\"\"\n    logger.info(f\"Restoring state for {self.id}\")\n\n    if not self.state_path.exists():\n        logger.info(f\"No state file found for {self.id}\")\n        return\n\n    try:\n        with self.state_path.open() as f:\n            d = json.load(f)\n            logger.debug(f\"State dict for {self.id}: {d}\")\n        self.from_dict(d=d)\n    except:\n        logger.exception(f\"Failed to load variables for {self.id}\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.run","title":"<code>run() -&gt; None</code>  <code>async</code>","text":"<p>Start the device's polling loop.</p> <p>This method starts the device's polling task and waits for all tasks to complete. The polling loop will run continuously until canceled.</p> Source code in <code>devices/device.py</code> <pre><code>async def run(self) -&gt; None:\n\"\"\"Start the device's polling loop.\n\n    This method starts the device's polling task and waits for all tasks\n    to complete. The polling loop will run continuously until canceled.\n    \"\"\"\n    logger.info(f\" Entering run for {self.DEVICE_MATCH}\")\n    # t = await self.poll()\n    t = run_task(self.poll())\n    self._tasks.add(t)\n    await asyncio.gather(*self._tasks)\n\n    logger.debug(f\"Exiting run for {self.id}\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.save_state","title":"<code>save_state() -&gt; None</code>","text":"<p>Save device state to disk.</p> <p>Persists the current device state (availability, status, variables) to a JSON file. Called automatically during each polling cycle.</p> Source code in <code>devices/device.py</code> <pre><code>def save_state(self) -&gt; None:\n\"\"\"Save device state to disk.\n\n    Persists the current device state (availability, status, variables)\n    to a JSON file. Called automatically during each polling cycle.\n    \"\"\"\n    logger.debug(f\"{self.__class__.__name__} {self.id} - Trying to save state...\")\n    try:\n        d = self.to_dict()\n\n        with self.state_path.open(\"w\") as f:\n            json.dump(d, f)\n\n        logger.debug(f\"Finished saving state! {self.id}: {d}\")\n\n    except Exception as e:\n        logger.error(f\"Unable to save state for {self.id} : {e}\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.save_updated_status","title":"<code>save_updated_status(updated_status: list[StatusVariables], timestamp: datetime) -&gt; None</code>","text":"<p>Save updated status variables to disk.</p> <p>Writes status changes to a CSV file in the device's data directory.</p> <p>Parameters:</p> Name Type Description Default <code>updated_status</code> <code>list[StatusVariables]</code> <p>List of status variables that have changed.</p> required <code>timestamp</code> <code>datetime</code> <p>Timestamp to use for the status file.</p> required Source code in <code>devices/device.py</code> <pre><code>def save_updated_status(\n    self, updated_status: list[StatusVariables], timestamp: datetime\n) -&gt; None:\n\"\"\"Save updated status variables to disk.\n\n    Writes status changes to a CSV file in the device's data directory.\n\n    Args:\n        updated_status: List of status variables that have changed.\n        timestamp: Timestamp to use for the status file.\n    \"\"\"\n    fp = self.create_filepath(timestamp, status=True)\n    results_list = []\n    for status_var in updated_status:\n        status_var_json = status_var.serialize()\n        results_list.append(\n            f\"{status_var_json['timestamp']},{status_var_json['error_name']},{status_var_json['flag']},{status_var_json['description']}\\n\"\n        )\n    with fp.open(\"a\") as f:\n        f.writelines(results_list)\n\n    logger.debug(f\"Saved {self.id} data to {fp}\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.save_vars","title":"<code>save_vars(vars: dict[str, DeviceVariable], timestamp: datetime, triggered_vars=False) -&gt; None</code>","text":"<p>Save device variables to disk.</p> <p>Writes variables to a CSV file in the device's data directory. Only variables that meet the save criteria (determined by <code>get_vars_to_save()</code>) are written.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>dict[str, DeviceVariable]</code> <p>Dictionary of device variables to save.</p> required <code>timestamp</code> <code>datetime</code> <p>Timestamp to use for the data file.</p> required <code>triggered_vars</code> <p>Whether these are status-triggered variables.</p> <code>False</code> Source code in <code>devices/device.py</code> <pre><code>def save_vars(\n    self, vars: dict[str, DeviceVariable], timestamp: datetime, triggered_vars=False\n) -&gt; None:\n\"\"\"Save device variables to disk.\n\n    Writes variables to a CSV file in the device's data directory.\n    Only variables that meet the save criteria (determined by\n    `get_vars_to_save()`) are written.\n\n    Args:\n        vars: Dictionary of device variables to save.\n        timestamp: Timestamp to use for the data file.\n        triggered_vars: Whether these are status-triggered variables.\n    \"\"\"\n    fp = self.create_filepath(timestamp)\n    vars_to_save = self.get_vars_to_save(vars, timestamp, triggered_vars)\n\n    if not vars_to_save:\n        logger.info(\"no vars were saved to disk\")\n        return None\n\n    results_list = []\n    for val_obj in vars_to_save.values():\n        var_json = val_obj.serialize()\n        results_list.append(\n            f\"{var_json['timestamp']},{var_json['variable_name']},{var_json['raw_data']},{var_json['unit']},{var_json['processed_data']}\\n\"\n        )\n\n    with fp.open(\"a\") as f:\n        f.writelines(results_list)\n\n    logger.debug(f\"Saved {self.id} data to {fp}\")\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.to_dict","title":"<code>to_dict() -&gt; dict[str, Any]</code>","text":"<p>Serialize device state to a dictionary.</p> <p>Creates a JSON-serializable dictionary containing the device ID, type, and all state objects defined in DEVICE_STATE_OBJECTS.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the device state.</p> Source code in <code>devices/device.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n\"\"\"Serialize device state to a dictionary.\n\n    Creates a JSON-serializable dictionary containing the device ID, type,\n    and all state objects defined in DEVICE_STATE_OBJECTS.\n\n    Returns:\n        Dictionary representation of the device state.\n    \"\"\"\n    d = {\n        \"device_id\": getattr(self, \"id\", None),\n        \"type\": self.__class__.__name__,\n    }\n\n    for key in self.DEVICE_STATE_OBJECTS:\n        val: DeviceStateObject = getattr(self, key, None)\n        if not isinstance(val, DeviceStateObject):\n            logger.info(\n                f\"{key} is not a proper DeviceStateObject it has not serialize method\"\n            )\n            continue\n        d[key] = val.serialize()\n\n    return d\n</code></pre>"},{"location":"api/devices/device/#devices.device.Device.update_from_device_conf","title":"<code>update_from_device_conf(device_conf: DeviceConfig) -&gt; None</code>","text":"<p>Update device configuration from a new DeviceConfig object.</p> <p>Parameters:</p> Name Type Description Default <code>device_conf</code> <code>DeviceConfig</code> <p>New device configuration to apply.</p> required Source code in <code>devices/device.py</code> <pre><code>def update_from_device_conf(self, device_conf: DeviceConfig) -&gt; None:\n\"\"\"Update device configuration from a new DeviceConfig object.\n\n    Args:\n        device_conf: New device configuration to apply.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/device/#functions","title":"Functions","text":""},{"location":"api/devices/device/#register_device","title":"register_device","text":"<p>Register a Device class to the factory registry.</p> <p>This decorator registers a Device subclass to the DEVICE_FACTORY dictionary, making it available for instantiation via <code>from_device_conf()</code>. The class is registered under all identifiers in its <code>DEVICE_MATCH</code> list.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>Type[D]</code> <p>The Device subclass to register.</p> required <p>Returns:</p> Type Description <code>Type[D]</code> <p>The class unchanged, allowing it to be used as a decorator.</p> Source code in <code>devices/device.py</code> <pre><code>def register_device(cls: Type[D]) -&gt; Type[D]:\n\"\"\"Register a Device class to the factory registry.\n\n    This decorator registers a Device subclass to the DEVICE_FACTORY dictionary,\n    making it available for instantiation via `from_device_conf()`. The class\n    is registered under all identifiers in its `DEVICE_MATCH` list.\n\n    Args:\n        cls: The Device subclass to register.\n\n    Returns:\n        The class unchanged, allowing it to be used as a decorator.\n    \"\"\"\n    logger.warning(f\"Registering {cls} to device factory\")\n    for matcher in cls.DEVICE_MATCH:\n        DEVICE_FACTORY[matcher] = cls\n    return cls\n</code></pre>"},{"location":"api/devices/device/#variables","title":"Variables","text":""},{"location":"api/devices/device/#devices.device.D","title":"<code>devices.device.D = TypeVar('D', bound='Device')</code>  <code>module-attribute</code>","text":""},{"location":"api/devices/device/#devices.device.DEVICE_FACTORY","title":"<code>devices.device.DEVICE_FACTORY: dict[str, Type[D]] = {}</code>  <code>module-attribute</code>","text":"<p>Factory registry for Device implementations.</p> <p>Maps device type identifiers (from DEVICE_MATCH) to their corresponding Device class implementations. This dictionary is populated by the <code>register_device</code> decorator.</p>"},{"location":"api/devices/deviceManager/","title":"devices.deviceManager","text":""},{"location":"api/devices/deviceManager/#classes","title":"Classes","text":""},{"location":"api/devices/deviceManager/#devicemanager","title":"DeviceManager","text":"<p>Manages device registration, lifecycle, and execution.</p> <p>The DeviceManager maintains a registry of Device instances and handles their creation from configuration, registration, execution, and removal. It coordinates device operations and manages their async tasks.</p> Source code in <code>devices/deviceManager.py</code> <pre><code>class DeviceManager:\n\"\"\"Manages device registration, lifecycle, and execution.\n\n    The DeviceManager maintains a registry of Device instances and handles\n    their creation from configuration, registration, execution, and removal.\n    It coordinates device operations and manages their async tasks.\n    \"\"\"\n\n    def __init__(self, environment: env.Environment) -&gt; None:\n\"\"\"Initialize the DeviceManager.\n\n        Args:\n            environment: Environment instance providing configuration and context.\n        \"\"\"\n        self.environment = environment\n        self.devices: dict[str, Device] = {}\n        self._tasks: list[asyncio.Task] = []\n\n    def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the DeviceManager.\n\n        Returns:\n            A string containing the class name and number of managed devices.\n        \"\"\"\n        params = \", \".join(\n            [\n                f\"number_devices={len(self.devices)}\",\n            ]\n        )\n\n        return \"\".join([self.__class__.__name__, \"(\", params, \")\"])\n\n    async def run(self):\n\"\"\"Initialize and register all devices from configuration.\n\n        Reads the device configuration from the environment and registers\n        all configured devices by creating them from their configurations.\n        \"\"\"\n        logger.info(f\"Entering run for {self}\")\n        devices_list = self.environment.config.all_devices.devices\n        for device_conf in devices_list:\n            self.register_device(device_conf.name, device_conf)\n\n        logger.debug(f\"Exiting run for {self}\")\n\n    def get_device(self, device_name: str) -&gt; Device | None:\n\"\"\"Retrieve a device from the registry by name.\n\n        Args:\n            device_name: The name of the device to retrieve.\n\n        Returns:\n            The Device instance if found, None otherwise.\n        \"\"\"\n        logger.debug(f\"Getting a device with {device_name} id\")\n        device = self.devices.get(device_name)\n        return device\n\n    def register_device(\n        self,\n        device_name: str,\n        device_conf: DeviceConfig | None = None,\n        device: Device | None = None,\n    ) -&gt; Device | None:\n\"\"\"Register a device with the manager.\n\n        Retrieves a device if it is already registered, creates it from a\n        device configuration if provided, or registers a provided device object.\n        If a new device is created or registered, its run task is started.\n\n        Args:\n            device_name: The name of the device. Acts as the key in the devices\n                dictionary.\n            device_conf: Optional device configuration to create the device using\n                the device's \"from_device_conf\" method. Defaults to None.\n            device: Optional Device object to register directly, as an alternative\n                to creating from device_conf. Defaults to None.\n\n        Returns:\n            The Device instance if successful, None if the device cannot be\n            created or if neither device_conf nor device is provided.\n        \"\"\"\n        dev = self.get_device(device_name)\n\n        if dev:\n            logger.debug(f\"Device {dev} is already registered\")\n            return dev\n\n        if not device and device_conf:\n            dev = Device.from_device_conf(device_name, self.environment, device_conf)\n            if not dev:\n                logger.warning(\n                    f\"Failed to create device {device_name} from device_conf {device_conf}\"\n                )\n                return None\n        elif device:\n            dev = device\n        else:\n            logger.error(\"Neither device nor device_conf provided\")\n            return None\n\n        self.devices[device_name] = dev\n        run_task(dev.run())\n        logger.debug(f\"{dev} device registered\")\n        return dev\n\n    async def remove_device(self, device_name: str) -&gt; None:\n\"\"\"Remove a device from the manager and cancel its tasks.\n\n        Cancels all tasks associated with the device and removes it from\n        the device registry.\n\n        Args:\n            device_name: The name of the device to remove.\n        \"\"\"\n        dev = self.get_device(device_name)\n        if dev:\n            await dev.cancel()\n            del self.devices[device_name]\n            logger.info(f\"Device {dev} is deleted\")\n        else:\n            logger.info(f\"Device {dev} doesn't exist\")\n\n    async def cancel(self):\n\"\"\"Cancel all managed tasks for this DeviceManager.\n\n        Sets the canceled flag and cancels all async tasks associated with\n        this manager, then waits for them to complete.\n        \"\"\"\n        self.canceled = True\n        for task in self._tasks:\n            logger.debug(f\"Canceling task {task}\")\n            task.cancel()\n\n        if self._tasks:\n            await asyncio.gather(*self._tasks, return_exceptions=True)\n        logger.info(f\"Cancel finished for {self}\")\n</code></pre>"},{"location":"api/devices/deviceManager/#devices.deviceManager.DeviceManager.__init__","title":"<code>__init__(environment: env.Environment) -&gt; None</code>","text":"<p>Initialize the DeviceManager.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>Environment instance providing configuration and context.</p> required Source code in <code>devices/deviceManager.py</code> <pre><code>def __init__(self, environment: env.Environment) -&gt; None:\n\"\"\"Initialize the DeviceManager.\n\n    Args:\n        environment: Environment instance providing configuration and context.\n    \"\"\"\n    self.environment = environment\n    self.devices: dict[str, Device] = {}\n    self._tasks: list[asyncio.Task] = []\n</code></pre>"},{"location":"api/devices/deviceManager/#devices.deviceManager.DeviceManager.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a string representation of the DeviceManager.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string containing the class name and number of managed devices.</p> Source code in <code>devices/deviceManager.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Return a string representation of the DeviceManager.\n\n    Returns:\n        A string containing the class name and number of managed devices.\n    \"\"\"\n    params = \", \".join(\n        [\n            f\"number_devices={len(self.devices)}\",\n        ]\n    )\n\n    return \"\".join([self.__class__.__name__, \"(\", params, \")\"])\n</code></pre>"},{"location":"api/devices/deviceManager/#devices.deviceManager.DeviceManager.cancel","title":"<code>cancel()</code>  <code>async</code>","text":"<p>Cancel all managed tasks for this DeviceManager.</p> <p>Sets the canceled flag and cancels all async tasks associated with this manager, then waits for them to complete.</p> Source code in <code>devices/deviceManager.py</code> <pre><code>async def cancel(self):\n\"\"\"Cancel all managed tasks for this DeviceManager.\n\n    Sets the canceled flag and cancels all async tasks associated with\n    this manager, then waits for them to complete.\n    \"\"\"\n    self.canceled = True\n    for task in self._tasks:\n        logger.debug(f\"Canceling task {task}\")\n        task.cancel()\n\n    if self._tasks:\n        await asyncio.gather(*self._tasks, return_exceptions=True)\n    logger.info(f\"Cancel finished for {self}\")\n</code></pre>"},{"location":"api/devices/deviceManager/#devices.deviceManager.DeviceManager.get_device","title":"<code>get_device(device_name: str) -&gt; Device | None</code>","text":"<p>Retrieve a device from the registry by name.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device to retrieve.</p> required <p>Returns:</p> Type Description <code>Device | None</code> <p>The Device instance if found, None otherwise.</p> Source code in <code>devices/deviceManager.py</code> <pre><code>def get_device(self, device_name: str) -&gt; Device | None:\n\"\"\"Retrieve a device from the registry by name.\n\n    Args:\n        device_name: The name of the device to retrieve.\n\n    Returns:\n        The Device instance if found, None otherwise.\n    \"\"\"\n    logger.debug(f\"Getting a device with {device_name} id\")\n    device = self.devices.get(device_name)\n    return device\n</code></pre>"},{"location":"api/devices/deviceManager/#devices.deviceManager.DeviceManager.register_device","title":"<code>register_device(device_name: str, device_conf: DeviceConfig | None = None, device: Device | None = None) -&gt; Device | None</code>","text":"<p>Register a device with the manager.</p> <p>Retrieves a device if it is already registered, creates it from a device configuration if provided, or registers a provided device object. If a new device is created or registered, its run task is started.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device. Acts as the key in the devices dictionary.</p> required <code>device_conf</code> <code>DeviceConfig | None</code> <p>Optional device configuration to create the device using the device's \"from_device_conf\" method. Defaults to None.</p> <code>None</code> <code>device</code> <code>Device | None</code> <p>Optional Device object to register directly, as an alternative to creating from device_conf. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Device | None</code> <p>The Device instance if successful, None if the device cannot be</p> <code>Device | None</code> <p>created or if neither device_conf nor device is provided.</p> Source code in <code>devices/deviceManager.py</code> <pre><code>def register_device(\n    self,\n    device_name: str,\n    device_conf: DeviceConfig | None = None,\n    device: Device | None = None,\n) -&gt; Device | None:\n\"\"\"Register a device with the manager.\n\n    Retrieves a device if it is already registered, creates it from a\n    device configuration if provided, or registers a provided device object.\n    If a new device is created or registered, its run task is started.\n\n    Args:\n        device_name: The name of the device. Acts as the key in the devices\n            dictionary.\n        device_conf: Optional device configuration to create the device using\n            the device's \"from_device_conf\" method. Defaults to None.\n        device: Optional Device object to register directly, as an alternative\n            to creating from device_conf. Defaults to None.\n\n    Returns:\n        The Device instance if successful, None if the device cannot be\n        created or if neither device_conf nor device is provided.\n    \"\"\"\n    dev = self.get_device(device_name)\n\n    if dev:\n        logger.debug(f\"Device {dev} is already registered\")\n        return dev\n\n    if not device and device_conf:\n        dev = Device.from_device_conf(device_name, self.environment, device_conf)\n        if not dev:\n            logger.warning(\n                f\"Failed to create device {device_name} from device_conf {device_conf}\"\n            )\n            return None\n    elif device:\n        dev = device\n    else:\n        logger.error(\"Neither device nor device_conf provided\")\n        return None\n\n    self.devices[device_name] = dev\n    run_task(dev.run())\n    logger.debug(f\"{dev} device registered\")\n    return dev\n</code></pre>"},{"location":"api/devices/deviceManager/#devices.deviceManager.DeviceManager.remove_device","title":"<code>remove_device(device_name: str) -&gt; None</code>  <code>async</code>","text":"<p>Remove a device from the manager and cancel its tasks.</p> <p>Cancels all tasks associated with the device and removes it from the device registry.</p> <p>Parameters:</p> Name Type Description Default <code>device_name</code> <code>str</code> <p>The name of the device to remove.</p> required Source code in <code>devices/deviceManager.py</code> <pre><code>async def remove_device(self, device_name: str) -&gt; None:\n\"\"\"Remove a device from the manager and cancel its tasks.\n\n    Cancels all tasks associated with the device and removes it from\n    the device registry.\n\n    Args:\n        device_name: The name of the device to remove.\n    \"\"\"\n    dev = self.get_device(device_name)\n    if dev:\n        await dev.cancel()\n        del self.devices[device_name]\n        logger.info(f\"Device {dev} is deleted\")\n    else:\n        logger.info(f\"Device {dev} doesn't exist\")\n</code></pre>"},{"location":"api/devices/deviceManager/#devices.deviceManager.DeviceManager.run","title":"<code>run()</code>  <code>async</code>","text":"<p>Initialize and register all devices from configuration.</p> <p>Reads the device configuration from the environment and registers all configured devices by creating them from their configurations.</p> Source code in <code>devices/deviceManager.py</code> <pre><code>async def run(self):\n\"\"\"Initialize and register all devices from configuration.\n\n    Reads the device configuration from the environment and registers\n    all configured devices by creating them from their configurations.\n    \"\"\"\n    logger.info(f\"Entering run for {self}\")\n    devices_list = self.environment.config.all_devices.devices\n    for device_conf in devices_list:\n        self.register_device(device_conf.name, device_conf)\n\n    logger.debug(f\"Exiting run for {self}\")\n</code></pre>"},{"location":"api/devices/deviceVariables/","title":"devices.deviceVariables","text":""},{"location":"api/devices/deviceVariables/#classes","title":"Classes","text":""},{"location":"api/devices/deviceVariables/#variablesconfs","title":"VariablesConfs","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration settings for device variable saving behavior.</p> <p>Attributes:</p> Name Type Description <code>save_interval</code> <code>str</code> <p>Time interval between saves (e.g., \"1m\", \"5s\"). Defaults to \"1m\".</p> <code>save_change_threshold</code> <code>int</code> <p>Minimum change in raw_data value required to trigger a save. Defaults to 0.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>class VariablesConfs(BaseModel):\n\"\"\"Configuration settings for device variable saving behavior.\n\n    Attributes:\n        save_interval: Time interval between saves (e.g., \"1m\", \"5s\"). Defaults to \"1m\".\n        save_change_threshold: Minimum change in raw_data value required to trigger\n            a save. Defaults to 0.\n    \"\"\"\n\n    save_interval: str = \"1m\"\n    save_change_threshold: int = 0\n</code></pre>"},{"location":"api/devices/deviceVariables/#deviceavailability","title":"DeviceAvailability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Tracks device availability metrics (uptime and downtime).</p> <p>Attributes:</p> Name Type Description <code>uptime</code> <code>float</code> <p>Total uptime in seconds. Defaults to 0.0.</p> <code>downtime</code> <code>float</code> <p>Total downtime in seconds. Defaults to 0.0.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>class DeviceAvailability(BaseModel):\n\"\"\"Tracks device availability metrics (uptime and downtime).\n\n    Attributes:\n        uptime: Total uptime in seconds. Defaults to 0.0.\n        downtime: Total downtime in seconds. Defaults to 0.0.\n    \"\"\"\n\n    uptime: float = 0.0\n    downtime: float = 0.0\n\n    def serialize(self) -&gt; dict[str, float]:\n\"\"\"Serialize the device availability to a dictionary.\n\n        Returns:\n            Dictionary containing uptime and downtime values.\n        \"\"\"\n        return self.model_dump(mode=\"json\")\n\n    def deserialize(self, dev_avail_dict: dict[str, float]):\n\"\"\"Deserialize device availability from a dictionary.\n\n        Args:\n            dev_avail_dict: Dictionary containing uptime and/or downtime values.\n        \"\"\"\n        if not dev_avail_dict:\n            logger.debug(\n                \"dev_avail_dict is empty can not deserialize DeviceAvailability\"\n            )\n            return\n        for k, v in dev_avail_dict.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceAvailability.deserialize","title":"<code>deserialize(dev_avail_dict: dict[str, float])</code>","text":"<p>Deserialize device availability from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dev_avail_dict</code> <code>dict[str, float]</code> <p>Dictionary containing uptime and/or downtime values.</p> required Source code in <code>devices/deviceVariables.py</code> <pre><code>def deserialize(self, dev_avail_dict: dict[str, float]):\n\"\"\"Deserialize device availability from a dictionary.\n\n    Args:\n        dev_avail_dict: Dictionary containing uptime and/or downtime values.\n    \"\"\"\n    if not dev_avail_dict:\n        logger.debug(\n            \"dev_avail_dict is empty can not deserialize DeviceAvailability\"\n        )\n        return\n    for k, v in dev_avail_dict.items():\n        setattr(self, k, v)\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceAvailability.serialize","title":"<code>serialize() -&gt; dict[str, float]</code>","text":"<p>Serialize the device availability to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Dictionary containing uptime and downtime values.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>def serialize(self) -&gt; dict[str, float]:\n\"\"\"Serialize the device availability to a dictionary.\n\n    Returns:\n        Dictionary containing uptime and downtime values.\n    \"\"\"\n    return self.model_dump(mode=\"json\")\n</code></pre>"},{"location":"api/devices/deviceVariables/#devicevariable","title":"DeviceVariable","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single device variable with its value and metadata.</p> <p>Attributes:</p> Name Type Description <code>timestamp</code> <code>datetime</code> <p>Timestamp when the variable was read.</p> <code>variable_name</code> <code>str</code> <p>Name of the variable.</p> <code>raw_data</code> <code>Any</code> <p>Raw value of the variable (any type).</p> <code>unit</code> <code>str | None</code> <p>Optional unit of measurement for the variable.</p> <code>processed_data</code> <code>str | int | float | None</code> <p>Optional processed/transformed value of the variable.</p> <code>last_saving_timestamp</code> <code>datetime | None</code> <p>Optional timestamp of when this variable was last saved.</p> <code>_variable_confs</code> <code>VariablesConfs</code> <p>Configuration settings for this variable.</p> Config <p>extra: Set to \"ignore\" to ignore extra fields during validation. validate_by_name: Enable validation by field name.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>class DeviceVariable(BaseModel):\n\"\"\"Represents a single device variable with its value and metadata.\n\n    Attributes:\n        timestamp: Timestamp when the variable was read.\n        variable_name: Name of the variable.\n        raw_data: Raw value of the variable (any type).\n        unit: Optional unit of measurement for the variable.\n        processed_data: Optional processed/transformed value of the variable.\n        last_saving_timestamp: Optional timestamp of when this variable was last saved.\n        _variable_confs: Configuration settings for this variable.\n\n    Config:\n        extra: Set to \"ignore\" to ignore extra fields during validation.\n        validate_by_name: Enable validation by field name.\n    \"\"\"\n\n    timestamp: datetime\n    variable_name: str\n    raw_data: Any\n    unit: str | None = None\n    processed_data: str | int | float | None = None\n    last_saving_timestamp: datetime | None = None\n    _variable_confs: VariablesConfs\n\n    class Config:\n\"\"\"Pydantic model configuration.\"\"\"\n\n        extra = \"ignore\"\n        validate_by_name = True\n\n    def serialize(self, attributes_list: list[str] = []) -&gt; dict[str, Any]:\n\"\"\"Serialize the device variable to a dictionary.\n\n        Args:\n            attributes_list: Optional list of attribute names to include.\n                If empty, all attributes are included.\n\n        Returns:\n            Dictionary representation of the device variable.\n        \"\"\"\n        if not attributes_list:\n            return self.model_dump(mode=\"json\")\n\n        return self.model_dump(include=attributes_list, mode=\"json\")\n\n    def pretty_print(self) -&gt; None:\n\"\"\"Return a human-readable string representation of the variable.\n\n        Returns:\n            Formatted string representation of the variable.\n        \"\"\"\n        ...\n\n    def get_processed_data(self) -&gt; None:\n\"\"\"Process and update the processed_data field from raw_data.\"\"\"\n        ...\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceVariable.Config","title":"<code>Config</code>","text":"<p>Pydantic model configuration.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>class Config:\n\"\"\"Pydantic model configuration.\"\"\"\n\n    extra = \"ignore\"\n    validate_by_name = True\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceVariable.get_processed_data","title":"<code>get_processed_data() -&gt; None</code>","text":"<p>Process and update the processed_data field from raw_data.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>def get_processed_data(self) -&gt; None:\n\"\"\"Process and update the processed_data field from raw_data.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceVariable.pretty_print","title":"<code>pretty_print() -&gt; None</code>","text":"<p>Return a human-readable string representation of the variable.</p> <p>Returns:</p> Type Description <code>None</code> <p>Formatted string representation of the variable.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>def pretty_print(self) -&gt; None:\n\"\"\"Return a human-readable string representation of the variable.\n\n    Returns:\n        Formatted string representation of the variable.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceVariable.serialize","title":"<code>serialize(attributes_list: list[str] = []) -&gt; dict[str, Any]</code>","text":"<p>Serialize the device variable to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>attributes_list</code> <code>list[str]</code> <p>Optional list of attribute names to include. If empty, all attributes are included.</p> <code>[]</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the device variable.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>def serialize(self, attributes_list: list[str] = []) -&gt; dict[str, Any]:\n\"\"\"Serialize the device variable to a dictionary.\n\n    Args:\n        attributes_list: Optional list of attribute names to include.\n            If empty, all attributes are included.\n\n    Returns:\n        Dictionary representation of the device variable.\n    \"\"\"\n    if not attributes_list:\n        return self.model_dump(mode=\"json\")\n\n    return self.model_dump(include=attributes_list, mode=\"json\")\n</code></pre>"},{"location":"api/devices/deviceVariables/#vars","title":"Vars","text":"<p>               Bases: <code>BaseModel</code></p> <p>Collection of device variables organized by variable name.</p> <p>Attributes:</p> Name Type Description <code>vars_dict</code> <code>dict[str, DeviceVariable]</code> <p>Dictionary mapping variable names to DeviceVariable instances.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>class Vars(BaseModel):\n\"\"\"Collection of device variables organized by variable name.\n\n    Attributes:\n        vars_dict: Dictionary mapping variable names to DeviceVariable instances.\n    \"\"\"\n\n    vars_dict: dict[str, DeviceVariable] = {}\n\n    def serialize(self):\n\"\"\"Serialize all variables in the collection to a dictionary.\n\n        Returns:\n            Dictionary mapping variable names to their serialized representations.\n        \"\"\"\n        json_ready = {}\n        for k, v in self.vars_dict.items():\n            json_ready[k] = v.serialize()\n        return json_ready\n\n    def deserialize(self, json_dict: dict[str, dict], device_variables_confs: dict):\n\"\"\"Deserialize variables from a dictionary representation.\n\n        Restores DeviceVariable instances from serialized data, using the\n        provided device variable configurations.\n\n        Args:\n            json_dict: Dictionary mapping variable names to their serialized data.\n            device_variables_confs: Dictionary mapping variable names to their\n                VariablesConfs configurations.\n        \"\"\"\n        if not (json_dict or device_variables_confs):\n            logger.info(\"please provide both vars and device_variables_confs\")\n            return\n        for k, v in json_dict.items():\n            if k in device_variables_confs:\n                try:\n                    self.vars_dict[k] = DeviceVariable(**v)\n                except Exception as e:\n                    logger.warning(f\"can not restore ({k}), {e}\")\n                    continue\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.Vars.deserialize","title":"<code>deserialize(json_dict: dict[str, dict], device_variables_confs: dict)</code>","text":"<p>Deserialize variables from a dictionary representation.</p> <p>Restores DeviceVariable instances from serialized data, using the provided device variable configurations.</p> <p>Parameters:</p> Name Type Description Default <code>json_dict</code> <code>dict[str, dict]</code> <p>Dictionary mapping variable names to their serialized data.</p> required <code>device_variables_confs</code> <code>dict</code> <p>Dictionary mapping variable names to their VariablesConfs configurations.</p> required Source code in <code>devices/deviceVariables.py</code> <pre><code>def deserialize(self, json_dict: dict[str, dict], device_variables_confs: dict):\n\"\"\"Deserialize variables from a dictionary representation.\n\n    Restores DeviceVariable instances from serialized data, using the\n    provided device variable configurations.\n\n    Args:\n        json_dict: Dictionary mapping variable names to their serialized data.\n        device_variables_confs: Dictionary mapping variable names to their\n            VariablesConfs configurations.\n    \"\"\"\n    if not (json_dict or device_variables_confs):\n        logger.info(\"please provide both vars and device_variables_confs\")\n        return\n    for k, v in json_dict.items():\n        if k in device_variables_confs:\n            try:\n                self.vars_dict[k] = DeviceVariable(**v)\n            except Exception as e:\n                logger.warning(f\"can not restore ({k}), {e}\")\n                continue\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.Vars.serialize","title":"<code>serialize()</code>","text":"<p>Serialize all variables in the collection to a dictionary.</p> <p>Returns:</p> Type Description <p>Dictionary mapping variable names to their serialized representations.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>def serialize(self):\n\"\"\"Serialize all variables in the collection to a dictionary.\n\n    Returns:\n        Dictionary mapping variable names to their serialized representations.\n    \"\"\"\n    json_ready = {}\n    for k, v in self.vars_dict.items():\n        json_ready[k] = v.serialize()\n    return json_ready\n</code></pre>"},{"location":"api/devices/deviceVariables/#devicestateobject","title":"DeviceStateObject","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects that can be serialized and deserialized for state persistence.</p> <p>Classes implementing this protocol can save and restore their state, enabling device state persistence across application restarts.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>@runtime_checkable\nclass DeviceStateObject(Protocol):\n\"\"\"Protocol for objects that can be serialized and deserialized for state persistence.\n\n    Classes implementing this protocol can save and restore their state,\n    enabling device state persistence across application restarts.\n    \"\"\"\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize the object state to a dictionary.\n\n        Returns:\n            Dictionary representation of the object's state.\n        \"\"\"\n        ...\n\n    def deserialize(self):\n\"\"\"Deserialize the object state from a dictionary.\n\n        Restores the object's state from a previously serialized dictionary.\n        The method signature may vary by implementation to accept the\n        dictionary as a parameter.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceStateObject.deserialize","title":"<code>deserialize()</code>","text":"<p>Deserialize the object state from a dictionary.</p> <p>Restores the object's state from a previously serialized dictionary. The method signature may vary by implementation to accept the dictionary as a parameter.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>def deserialize(self):\n\"\"\"Deserialize the object state from a dictionary.\n\n    Restores the object's state from a previously serialized dictionary.\n    The method signature may vary by implementation to accept the\n    dictionary as a parameter.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/deviceVariables/#devices.deviceVariables.DeviceStateObject.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>","text":"<p>Serialize the object state to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the object's state.</p> Source code in <code>devices/deviceVariables.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize the object state to a dictionary.\n\n    Returns:\n        Dictionary representation of the object's state.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/devices_func/","title":"devices.devices_func","text":""},{"location":"api/devices/devices_func/#functions","title":"Functions","text":""},{"location":"api/devices/devices_func/#get_device_manufacturer","title":"get_device_manufacturer","text":"<p>Extract the manufacturer name from a device identifier string.</p> <p>Supports two device identifier formats: - Third-party format:  (e.g., \"12345\") - MAC address format: XX:XX:XX:XX:XX:XX (returns \"MeshPower\") <p>Parameters:</p> Name Type Description Default <code>device_string</code> <p>Device identifier string in one of the supported formats.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The manufacturer name if a match is found, empty string otherwise.</p> <code>str</code> <p>MAC addresses always return \"MeshPower\".</p> Source code in <code>devices/devices_func.py</code> <pre><code>def get_device_manufacturer(device_string) -&gt; str:\n\"\"\"Extract the manufacturer name from a device identifier string.\n\n    Supports two device identifier formats:\n    - Third-party format: &lt;manufacturer&gt;&lt;serial_number&gt; (e.g., \"&lt;Epever&gt;12345\")\n    - MAC address format: XX:XX:XX:XX:XX:XX (returns \"MeshPower\")\n\n    Args:\n        device_string: Device identifier string in one of the supported formats.\n\n    Returns:\n        The manufacturer name if a match is found, empty string otherwise.\n        MAC addresses always return \"MeshPower\".\n    \"\"\"\n    match = DEVICE_PATTERN_THIRD_PARTY.match(device_string)\n    if match and match.group(MANUFACTURER):\n        return match.group(MANUFACTURER)\n\n    match = DEVICE_PATTERN_MAC_ADDRESS.match(device_string)\n    if match:\n        return \"MeshPower\"\n\n    logger.warning(\"Unable to match manufacturer for device: %s\", device_string)\n    return \"\"\n</code></pre>"},{"location":"api/devices/devices_func/#get_device_id","title":"get_device_id","text":"<p>Extract the device ID (serial number or MAC address) from a device identifier string.</p> <p>Supports two device identifier formats: - Third-party format:  (returns serial_number) - MAC address format: XX:XX:XX:XX:XX:XX (returns the MAC address as-is) <p>Parameters:</p> Name Type Description Default <code>device_string</code> <p>Device identifier string in one of the supported formats.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The device ID (serial number or MAC address) if a match is found,</p> <code>str</code> <p>empty string otherwise.</p> Source code in <code>devices/devices_func.py</code> <pre><code>def get_device_id(device_string) -&gt; str:\n\"\"\"Extract the device ID (serial number or MAC address) from a device identifier string.\n\n    Supports two device identifier formats:\n    - Third-party format: &lt;manufacturer&gt;&lt;serial_number&gt; (returns serial_number)\n    - MAC address format: XX:XX:XX:XX:XX:XX (returns the MAC address as-is)\n\n    Args:\n        device_string: Device identifier string in one of the supported formats.\n\n    Returns:\n        The device ID (serial number or MAC address) if a match is found,\n        empty string otherwise.\n    \"\"\"\n    match = DEVICE_PATTERN_THIRD_PARTY.match(device_string)\n    if match and match.group(SERIAL_NUMBER):\n        return match.group(SERIAL_NUMBER)\n\n    match = DEVICE_PATTERN_MAC_ADDRESS.match(device_string)\n    if match:\n        return device_string\n\n    logger.warning(\"Unable to extract serial number for device: %s\", device_string)\n    return \"\"\n</code></pre>"},{"location":"api/devices/devices_func/#variables","title":"Variables","text":""},{"location":"api/devices/devices_func/#devices.devices_func.DEVICE_PATTERN_THIRD_PARTY","title":"<code>devices.devices_func.DEVICE_PATTERN_THIRD_PARTY = re.compile('&lt;(?P&lt;manufacturer&gt;\\\\w+)&gt;(?P&lt;serial_number&gt;[\\\\w\\\\d]+)')</code>  <code>module-attribute</code>","text":"<p>Regular expression pattern for third-party device format: ."},{"location":"api/devices/devices_func/#devices.devices_func.DEVICE_PATTERN_MAC_ADDRESS","title":"<code>devices.devices_func.DEVICE_PATTERN_MAC_ADDRESS = re.compile('^[a-fA-F0-9]{2}(:[a-fA-F0-9]{2}){5}$')</code>  <code>module-attribute</code>","text":"<p>Regular expression pattern for MAC address format (XX:XX:XX:XX:XX:XX).</p>"},{"location":"api/devices/devices_func/#devices.devices_func.MANUFACTURER","title":"<code>devices.devices_func.MANUFACTURER = 'manufacturer'</code>  <code>module-attribute</code>","text":"<p>Group name for manufacturer in regex match groups.</p>"},{"location":"api/devices/devices_func/#devices.devices_func.SERIAL_NUMBER","title":"<code>devices.devices_func.SERIAL_NUMBER = 'serial_number'</code>  <code>module-attribute</code>","text":"<p>Group name for serial number in regex match groups.</p>"},{"location":"api/devices/interface/","title":"devices.interface","text":""},{"location":"api/devices/interface/#classes","title":"Classes","text":""},{"location":"api/devices/interface/#interface","title":"Interface","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for device communication implementations.</p> <p>Classes implementing this protocol must provide methods to initialize, read data from, check, and close connections to devices. This is typically used for communication protocols like Modbus RTU.</p> Source code in <code>devices/interface.py</code> <pre><code>class Interface(Protocol):\n\"\"\"Protocol defining the interface for device communication implementations.\n\n    Classes implementing this protocol must provide methods to initialize,\n    read data from, check, and close connections to devices. This is typically\n    used for communication protocols like Modbus RTU.\n    \"\"\"\n\n    async def init_connection(self) -&gt; None:\n\"\"\"Initialize the connection to the device.\n\n        Establishes a connection to the device and performs any necessary\n        setup operations.\n        \"\"\"\n        ...\n\n    async def read_data(self, address: int, count: int) -&gt; list[int]:\n\"\"\"Read data from the device.\n\n        Args:\n            address: Starting address/register to read from.\n            count: Number of registers/values to read.\n\n        Returns:\n            List of integer values read from the device.\n        \"\"\"\n        ...\n\n    async def close_connection(self) -&gt; None:\n\"\"\"Close the connection to the device.\n\n        Performs cleanup operations and closes the connection gracefully.\n        \"\"\"\n        ...\n\n    def check_connection(self) -&gt; bool:\n\"\"\"Check if the connection to the device is active.\n\n        Returns:\n            True if the connection is active, False otherwise.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/devices/interface/#devices.interface.Interface.check_connection","title":"<code>check_connection() -&gt; bool</code>","text":"<p>Check if the connection to the device is active.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the connection is active, False otherwise.</p> Source code in <code>devices/interface.py</code> <pre><code>def check_connection(self) -&gt; bool:\n\"\"\"Check if the connection to the device is active.\n\n    Returns:\n        True if the connection is active, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/interface/#devices.interface.Interface.close_connection","title":"<code>close_connection() -&gt; None</code>  <code>async</code>","text":"<p>Close the connection to the device.</p> <p>Performs cleanup operations and closes the connection gracefully.</p> Source code in <code>devices/interface.py</code> <pre><code>async def close_connection(self) -&gt; None:\n\"\"\"Close the connection to the device.\n\n    Performs cleanup operations and closes the connection gracefully.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/interface/#devices.interface.Interface.init_connection","title":"<code>init_connection() -&gt; None</code>  <code>async</code>","text":"<p>Initialize the connection to the device.</p> <p>Establishes a connection to the device and performs any necessary setup operations.</p> Source code in <code>devices/interface.py</code> <pre><code>async def init_connection(self) -&gt; None:\n\"\"\"Initialize the connection to the device.\n\n    Establishes a connection to the device and performs any necessary\n    setup operations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/interface/#devices.interface.Interface.read_data","title":"<code>read_data(address: int, count: int) -&gt; list[int]</code>  <code>async</code>","text":"<p>Read data from the device.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>Starting address/register to read from.</p> required <code>count</code> <code>int</code> <p>Number of registers/values to read.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>List of integer values read from the device.</p> Source code in <code>devices/interface.py</code> <pre><code>async def read_data(self, address: int, count: int) -&gt; list[int]:\n\"\"\"Read data from the device.\n\n    Args:\n        address: Starting address/register to read from.\n        count: Number of registers/values to read.\n\n    Returns:\n        List of integer values read from the device.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/interface/#functions","title":"Functions","text":""},{"location":"api/devices/interface/#register_interface","title":"register_interface","text":"<p>Register an Interface class to the factory registry.</p> <p>This decorator registers a class that implements the Interface protocol to the INTERFACE_FACTORY dictionary, making it available for retrieval via <code>get_interface_cls()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[Interface]</code> <p>The Interface implementation class to register.</p> required <p>Returns:</p> Type Description <code>type[Interface]</code> <p>The class unchanged, allowing it to be used as a decorator.</p> Source code in <code>devices/interface.py</code> <pre><code>def register_interface(cls: type[\"Interface\"]) -&gt; type[\"Interface\"]:\n\"\"\"Register an Interface class to the factory registry.\n\n    This decorator registers a class that implements the Interface protocol\n    to the INTERFACE_FACTORY dictionary, making it available for retrieval\n    via `get_interface_cls()`.\n\n    Args:\n        cls: The Interface implementation class to register.\n\n    Returns:\n        The class unchanged, allowing it to be used as a decorator.\n    \"\"\"\n    logger.warning(f\"Registering {cls} to interface factory\")\n    INTERFACE_FACTORY[cls.__name__] = cls\n    return cls\n</code></pre>"},{"location":"api/devices/interface/#get_interface_cls","title":"get_interface_cls","text":"<p>Retrieve an Interface class from the factory registry.</p> <p>Parameters:</p> Name Type Description Default <code>interface_name</code> <code>str</code> <p>The name of the Interface class to retrieve.</p> required <p>Returns:</p> Type Description <code>type[Interface] | None</code> <p>The Interface class if found, None otherwise. Logs a warning</p> <code>type[Interface] | None</code> <p>if the interface name is not found in the registry.</p> Source code in <code>devices/interface.py</code> <pre><code>def get_interface_cls(interface_name: str) -&gt; type[\"Interface\"] | None:\n\"\"\"Retrieve an Interface class from the factory registry.\n\n    Args:\n        interface_name: The name of the Interface class to retrieve.\n\n    Returns:\n        The Interface class if found, None otherwise. Logs a warning\n        if the interface name is not found in the registry.\n    \"\"\"\n    cls = INTERFACE_FACTORY.get(interface_name, None)\n    if cls is None:\n        logger.warning(f\"interface {interface_name} not found in {INTERFACE_FACTORY=}\")\n        return None\n    return cls\n</code></pre>"},{"location":"api/devices/interface/#variables","title":"Variables","text":""},{"location":"api/devices/interface/#devices.interface.INTERFACE_FACTORY","title":"<code>devices.interface.INTERFACE_FACTORY: dict[str, type[Interface]] = {}</code>  <code>module-attribute</code>","text":"<p>Factory registry for Interface implementations.</p> <p>Maps interface class names to their corresponding Interface class implementations. This dictionary is populated by the <code>register_interface</code> decorator.</p>"},{"location":"api/devices/status/","title":"devices.status","text":""},{"location":"api/devices/status/#classes","title":"Classes","text":""},{"location":"api/devices/status/#statusflags","title":"StatusFlags","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of device status flag levels.</p> <p>Attributes:</p> Name Type Description <code>OK</code> <p>Device is operating normally.</p> <code>WARNING</code> <p>Device has a warning condition.</p> <code>ERROR</code> <p>Device has an error condition.</p> <code>URGENT</code> <p>Device has an urgent condition requiring immediate attention.</p> Source code in <code>devices/status.py</code> <pre><code>class StatusFlags(Enum):\n\"\"\"Enumeration of device status flag levels.\n\n    Attributes:\n        OK: Device is operating normally.\n        WARNING: Device has a warning condition.\n        ERROR: Device has an error condition.\n        URGENT: Device has an urgent condition requiring immediate attention.\n    \"\"\"\n\n    OK = \"ok\"\n    WARNING = \"warning\"\n    ERROR = \"error\"\n    URGENT = \"urgent\"\n</code></pre>"},{"location":"api/devices/status/#comparisons","title":"Comparisons","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of comparison operators for threshold checking.</p> <p>Attributes:</p> Name Type Description <code>EQUAL</code> <p>Check if value equals threshold.</p> <code>EQUAL_OR_LESS</code> <p>Check if value is less than or equal to threshold.</p> <code>EQUAL_OR_GREATER</code> <p>Check if value is greater than or equal to threshold.</p> <code>LESS_THAN</code> <p>Check if value is less than threshold.</p> <code>GREATER_THAN</code> <p>Check if value is greater than threshold.</p> <code>AND</code> <p>Logical AND operation.</p> Source code in <code>devices/status.py</code> <pre><code>class Comparisons(Enum):\n\"\"\"Enumeration of comparison operators for threshold checking.\n\n    Attributes:\n        EQUAL: Check if value equals threshold.\n        EQUAL_OR_LESS: Check if value is less than or equal to threshold.\n        EQUAL_OR_GREATER: Check if value is greater than or equal to threshold.\n        LESS_THAN: Check if value is less than threshold.\n        GREATER_THAN: Check if value is greater than threshold.\n        AND: Logical AND operation.\n    \"\"\"\n\n    EQUAL = \"equal\"\n    EQUAL_OR_LESS = \"equal_or_less\"\n    EQUAL_OR_GREATER = \"equal_or_greater\"\n    LESS_THAN = \"less_than\"\n    GREATER_THAN = \"greater_than\"\n    AND = \"and\"\n</code></pre>"},{"location":"api/devices/status/#errorvariablesconfig","title":"ErrorVariablesConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for error detection based on device variables.</p> <p>Defines how a device variable should be monitored and what conditions trigger error, warning, or urgent status flags.</p> <p>Attributes:</p> Name Type Description <code>variable_name</code> <code>str</code> <p>Name of the device variable to monitor.</p> <code>error_name</code> <code>str</code> <p>Unique identifier for this error condition.</p> <code>description</code> <code>str</code> <p>Human-readable description of the error condition.</p> <code>flag</code> <code>StatusFlags</code> <p>Status flag to set when threshold condition is met.</p> <code>threshold</code> <code>Any</code> <p>Threshold value for comparison.</p> <code>comparison</code> <code>Comparisons</code> <p>Comparison operator to use for threshold checking.</p> <code>save_interval</code> <code>str</code> <p>Time interval between status saves (e.g., \"1m\", \"5s\"). Defaults to \"1m\".</p> Source code in <code>devices/status.py</code> <pre><code>class ErrorVariablesConfig(BaseModel):\n\"\"\"Configuration for error detection based on device variables.\n\n    Defines how a device variable should be monitored and what conditions\n    trigger error, warning, or urgent status flags.\n\n    Attributes:\n        variable_name: Name of the device variable to monitor.\n        error_name: Unique identifier for this error condition.\n        description: Human-readable description of the error condition.\n        flag: Status flag to set when threshold condition is met.\n        threshold: Threshold value for comparison.\n        comparison: Comparison operator to use for threshold checking.\n        save_interval: Time interval between status saves (e.g., \"1m\", \"5s\").\n            Defaults to \"1m\".\n    \"\"\"\n\n    variable_name: str\n    error_name: str\n    description: str\n    flag: StatusFlags\n    threshold: Any\n    comparison: Comparisons\n    save_interval: str = \"1m\"\n</code></pre>"},{"location":"api/devices/status/#statusvariables","title":"StatusVariables","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single status/error condition state.</p> <p>Attributes:</p> Name Type Description <code>timestamp</code> <code>datetime</code> <p>Timestamp when this status was detected or updated.</p> <code>error_name</code> <code>str</code> <p>Unique identifier for the error condition.</p> <code>flag</code> <code>StatusFlags</code> <p>Current status flag level.</p> <code>description</code> <code>str</code> <p>Human-readable description of the status/error.</p> <code>last_saving_timestamp</code> <code>Optional[datetime]</code> <p>Timestamp of when this status was last saved.</p> <code>_err_var_config</code> <code>ErrorVariablesConfig</code> <p>Reference to the error variable configuration.</p> Config <p>use_enum_values: Use enum values in serialization. extra: Set to \"ignore\" to ignore extra fields during validation. validate_by_name: Enable validation by field name.</p> Source code in <code>devices/status.py</code> <pre><code>class StatusVariables(BaseModel):\n\"\"\"Represents a single status/error condition state.\n\n    Attributes:\n        timestamp: Timestamp when this status was detected or updated.\n        error_name: Unique identifier for the error condition.\n        flag: Current status flag level.\n        description: Human-readable description of the status/error.\n        last_saving_timestamp: Timestamp of when this status was last saved.\n        _err_var_config: Reference to the error variable configuration.\n\n    Config:\n        use_enum_values: Use enum values in serialization.\n        extra: Set to \"ignore\" to ignore extra fields during validation.\n        validate_by_name: Enable validation by field name.\n    \"\"\"\n\n    timestamp: datetime\n    error_name: str\n    flag: StatusFlags\n    description: str\n    last_saving_timestamp: Optional[datetime] = None\n    _err_var_config: ErrorVariablesConfig\n\n    class Config:\n\"\"\"Pydantic model configuration.\"\"\"\n\n        use_enum_values = True\n        extra = \"ignore\"\n        validate_by_name = True\n\n    def serialize(self, attributes_list: list[str] = []) -&gt; dict[str, Any]:\n\"\"\"Serialize the status variable to a dictionary.\n\n        Args:\n            attributes_list: Optional list of attribute names to include.\n                If empty, all attributes are included.\n\n        Returns:\n            Dictionary representation of the status variable.\n        \"\"\"\n        if not attributes_list:\n            return self.model_dump(mode=\"json\")\n        return self.model_dump(include=attributes_list, mode=\"json\")\n</code></pre>"},{"location":"api/devices/status/#devices.status.StatusVariables.Config","title":"<code>Config</code>","text":"<p>Pydantic model configuration.</p> Source code in <code>devices/status.py</code> <pre><code>class Config:\n\"\"\"Pydantic model configuration.\"\"\"\n\n    use_enum_values = True\n    extra = \"ignore\"\n    validate_by_name = True\n</code></pre>"},{"location":"api/devices/status/#devices.status.StatusVariables.serialize","title":"<code>serialize(attributes_list: list[str] = []) -&gt; dict[str, Any]</code>","text":"<p>Serialize the status variable to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>attributes_list</code> <code>list[str]</code> <p>Optional list of attribute names to include. If empty, all attributes are included.</p> <code>[]</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary representation of the status variable.</p> Source code in <code>devices/status.py</code> <pre><code>def serialize(self, attributes_list: list[str] = []) -&gt; dict[str, Any]:\n\"\"\"Serialize the status variable to a dictionary.\n\n    Args:\n        attributes_list: Optional list of attribute names to include.\n            If empty, all attributes are included.\n\n    Returns:\n        Dictionary representation of the status variable.\n    \"\"\"\n    if not attributes_list:\n        return self.model_dump(mode=\"json\")\n    return self.model_dump(include=attributes_list, mode=\"json\")\n</code></pre>"},{"location":"api/devices/status/#status","title":"Status","text":"<p>               Bases: <code>BaseModel</code></p> <p>Manages device status monitoring, error detection, and state tracking.</p> <p>This class monitors device variables against configured thresholds, tracks status changes, and manages state history for persistence. It evaluates device variables against error configurations and determines when status changes should be saved.</p> <p>Attributes:</p> Name Type Description <code>state</code> <code>list[StatusVariables]</code> <p>Current list of status variables representing active status conditions.</p> <code>state_history</code> <code>dict[str, StatusVariables]</code> <p>Dictionary mapping error names to their last saved status.</p> <code>error_variable_config_list</code> <code>list[ErrorVariablesConfig]</code> <p>List of error variable configurations to monitor.</p> Source code in <code>devices/status.py</code> <pre><code>class Status(BaseModel):\n\"\"\"Manages device status monitoring, error detection, and state tracking.\n\n    This class monitors device variables against configured thresholds,\n    tracks status changes, and manages state history for persistence.\n    It evaluates device variables against error configurations and determines\n    when status changes should be saved.\n\n    Attributes:\n        state: Current list of status variables representing active status conditions.\n        state_history: Dictionary mapping error names to their last saved status.\n        error_variable_config_list: List of error variable configurations to monitor.\n    \"\"\"\n\n    state: list[StatusVariables] = []\n    state_history: dict[str, StatusVariables] = {}\n    error_variable_config_list: list[ErrorVariablesConfig] = []\n\n    def __init__(self, error_variables_path):\n\"\"\"Initialize Status with error variable configurations.\n\n        Args:\n            error_variables_path: Path to YAML file containing error variable\n                configurations.\n        \"\"\"\n        super().__init__()\n\n        self.error_variable_config_list = self.load_error_variable_config_list(\n            error_variables_path\n        )\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize the status state to a dictionary.\n\n        Returns:\n            Dictionary containing serialized state and state_history.\n        \"\"\"\n        data = {}\n        for var in [\"state\", \"state_history\"]:\n            value = getattr(self, var, None)\n            if value is None:\n                continue\n\n            adapter = TypeAdapter(type(value))\n            data[var] = adapter.dump_python(value, mode=\"json\")\n        return data\n\n    def deserialize(self, status_dict: dict[str, list | dict]) -&gt; Self | None:\n\"\"\"Deserialize status state from a dictionary.\n\n        Restores the state and state_history from previously serialized data.\n\n        Args:\n            status_dict: Dictionary containing serialized state and state_history.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        if not status_dict:\n            logger.debug(\"status_dict is empty can not deserialize status\")\n            return\n        for i in self.error_variable_config_list:\n            try:\n                state_dict = next(\n                    (\n                        d\n                        for d in status_dict[\"state\"]\n                        if d.get(\"error_name\") == i.error_name\n                    ),\n                    None,\n                )\n\n                state_history_dict = status_dict[\"state_history\"].get(i.error_name)\n                self.state_history[i.error_name] = StatusVariables(**state_history_dict)\n                self.state.append(**state_dict)\n            except Exception as e:\n                logger.debug(f\"could not restore ({i.error_name}), due to {e}\")\n            continue\n\n        return self\n\n    def load_error_variable_config_list(self, path) -&gt; None:\n\"\"\"Load error variable configurations from a YAML file.\n\n        Args:\n            path: Path to the YAML file containing error variable configurations.\n\n        Returns:\n            List of ErrorVariablesConfig instances, or None if file not found.\n        \"\"\"\n        try:\n            with open(path, \"r\") as f:\n                data = yaml.safe_load(f)\n            return [ErrorVariablesConfig(**v) for v in data]\n        except FileNotFoundError:\n            logger.warning(f\"file={path} not found\")\n\n    def update_state_and_state_history(\n        self,\n        timestamp: datetime,\n        error_variable_config: ErrorVariablesConfig,\n        flag_enum: StatusFlags,\n    ) -&gt; bool:\n\"\"\"Update state with a new status variable and check if flag changed.\n\n        Creates a new StatusVariables instance, adds it to the state list,\n        and checks if the flag has changed compared to the state history.\n\n        Args:\n            timestamp: Timestamp for the new status.\n            error_variable_config: Error variable configuration.\n            flag_enum: Status flag to set.\n\n        Returns:\n            True if the flag matches the previous state (no change),\n            False if the flag has changed or no previous state exists.\n        \"\"\"\n        status_obj = StatusVariables(\n            error_name=error_variable_config.error_name,\n            flag=flag_enum,\n            description=error_variable_config.description,\n            timestamp=timestamp,\n        )\n        status_obj._err_var_config = error_variable_config\n        self.state.append(status_obj)\n\n        if not self.state_history:\n            return True\n\n        old_state = self.state_history.get(error_variable_config.error_name, None)\n        if not old_state or old_state.flag != status_obj.flag:\n            return False\n        return True\n\n    def compare_vars(\n        self,\n        timestamp: datetime,\n        device_variable: DeviceVariable,\n        error_variable_conf: ErrorVariablesConfig,\n    ) -&gt; bool:\n\"\"\"Compare a device variable against its error configuration threshold.\n\n        Evaluates the device variable's processed_data against the threshold\n        using the configured comparison operator. Updates state accordingly\n        and returns whether the threshold condition was met (triggered).\n\n        Args:\n            timestamp: Timestamp for status evaluation.\n            device_variable: Device variable to evaluate.\n            error_variable_conf: Error variable configuration with threshold\n                and comparison settings.\n\n        Returns:\n            True if the threshold condition was met (error triggered),\n            False if the variable is within normal limits (OK status).\n        \"\"\"\n        if not (error_variable_conf.comparison and error_variable_conf.flag):\n            return False\n\n        op = COMPARISON_OPS.get(error_variable_conf.comparison)\n        if op and op(device_variable.processed_data, error_variable_conf.threshold):\n            return self.update_state_and_state_history(\n                timestamp=timestamp,\n                error_variable_config=error_variable_conf,\n                flag_enum=error_variable_conf.flag,\n            )\n\n        return self.update_state_and_state_history(\n            timestamp=timestamp,\n            error_variable_config=error_variable_conf,\n            flag_enum=StatusFlags.OK,\n        )\n\n    def update_state_history_and_saving_ts(\n        self, timestamp, new_state: StatusVariables\n    ) -&gt; StatusVariables:\n\"\"\"Update state history with a new state and set its saving timestamp.\n\n        Args:\n            timestamp: Timestamp to set as the last saving timestamp.\n            new_state: StatusVariables instance to save to history.\n\n        Returns:\n            The updated StatusVariables instance with last_saving_timestamp set.\n        \"\"\"\n        new_state.last_saving_timestamp = timestamp\n        self.state_history[new_state.error_name] = new_state\n        return new_state\n\n    def get_status_to_save(self, timestamp) -&gt; list[StatusVariables] | None:\n\"\"\"Determine which status variables should be saved to disk.\n\n        Status variables are saved if:\n        - They are new (not in state_history)\n        - Their flag has changed since last save\n        - The save interval has elapsed since last save\n\n        Args:\n            timestamp: Current timestamp for comparison.\n\n        Returns:\n            List of StatusVariables to save, sorted by error_name, or None\n            if no status needs to be saved.\n        \"\"\"\n        status_to_save = []\n        if not self.state_history:\n            for state in self.state:\n                status_to_save.append(\n                    self.update_state_history_and_saving_ts(timestamp, state)\n                )\n            return sorted(\n                status_to_save, key=lambda status_to_save: status_to_save.error_name\n            )\n\n        for new_state in self.state:\n            old_state = self.state_history.get(new_state.error_name, None)\n            if not old_state:\n                status_to_save.append(\n                    self.update_state_history_and_saving_ts(timestamp, new_state)\n                )\n                continue\n\n            if timestamp - old_state.last_saving_timestamp &gt; timedelta(\n                seconds=timeparse(new_state._err_var_config.save_interval)\n            ):\n                status_to_save.append(\n                    self.update_state_history_and_saving_ts(timestamp, new_state)\n                )\n\n            if old_state.flag != new_state.flag:\n                status_to_save.append(\n                    self.update_state_history_and_saving_ts(timestamp, new_state)\n                )\n\n        if not status_to_save:\n            return None\n        return sorted(\n            status_to_save, key=lambda status_to_save: status_to_save.error_name\n        )\n\n    def parse_vars(\n        self, vars: dict[str, DeviceVariable], timestamp: datetime\n    ) -&gt; tuple[list[StatusVariables], dict[str, DeviceVariable]] | tuple[None, None]:\n\"\"\"Parse device variables and evaluate status conditions.\n\n        Evaluates all device variables against their error configurations,\n        updates the status state, and determines which status variables\n        should be saved. Also identifies which variables triggered error\n        conditions.\n\n        Args:\n            vars: Dictionary mapping variable names to DeviceVariable instances.\n            timestamp: Timestamp for status evaluation.\n\n        Returns:\n            Tuple of (list of StatusVariables to save, dict of triggered variables),\n            or (None, None) if no status needs to be saved or error configs are missing.\n        \"\"\"\n        if not self.error_variable_config_list:\n            logger.error(\"error variable list was not provided\")\n            return None, None\n        self.state.clear()\n        triggered_vars = {}\n        for err_var_conf in self.error_variable_config_list:\n            vars_to_compare = vars.get(err_var_conf.variable_name, None)\n            if not vars_to_compare:\n                logger.debug(\n                    f\"error name: {err_var_conf.error_name} not found in {vars=}\"\n                )\n                continue\n            if self.compare_vars(\n                timestamp=timestamp,\n                device_variable=vars_to_compare,\n                error_variable_conf=err_var_conf,\n            ):\n                triggered_vars[err_var_conf.variable_name] = vars_to_compare\n        status_to_save = self.get_status_to_save(timestamp=timestamp)\n        if not status_to_save:\n            return (None, None)\n        return (status_to_save, triggered_vars)\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.__init__","title":"<code>__init__(error_variables_path)</code>","text":"<p>Initialize Status with error variable configurations.</p> <p>Parameters:</p> Name Type Description Default <code>error_variables_path</code> <p>Path to YAML file containing error variable configurations.</p> required Source code in <code>devices/status.py</code> <pre><code>def __init__(self, error_variables_path):\n\"\"\"Initialize Status with error variable configurations.\n\n    Args:\n        error_variables_path: Path to YAML file containing error variable\n            configurations.\n    \"\"\"\n    super().__init__()\n\n    self.error_variable_config_list = self.load_error_variable_config_list(\n        error_variables_path\n    )\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.compare_vars","title":"<code>compare_vars(timestamp: datetime, device_variable: DeviceVariable, error_variable_conf: ErrorVariablesConfig) -&gt; bool</code>","text":"<p>Compare a device variable against its error configuration threshold.</p> <p>Evaluates the device variable's processed_data against the threshold using the configured comparison operator. Updates state accordingly and returns whether the threshold condition was met (triggered).</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>datetime</code> <p>Timestamp for status evaluation.</p> required <code>device_variable</code> <code>DeviceVariable</code> <p>Device variable to evaluate.</p> required <code>error_variable_conf</code> <code>ErrorVariablesConfig</code> <p>Error variable configuration with threshold and comparison settings.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the threshold condition was met (error triggered),</p> <code>bool</code> <p>False if the variable is within normal limits (OK status).</p> Source code in <code>devices/status.py</code> <pre><code>def compare_vars(\n    self,\n    timestamp: datetime,\n    device_variable: DeviceVariable,\n    error_variable_conf: ErrorVariablesConfig,\n) -&gt; bool:\n\"\"\"Compare a device variable against its error configuration threshold.\n\n    Evaluates the device variable's processed_data against the threshold\n    using the configured comparison operator. Updates state accordingly\n    and returns whether the threshold condition was met (triggered).\n\n    Args:\n        timestamp: Timestamp for status evaluation.\n        device_variable: Device variable to evaluate.\n        error_variable_conf: Error variable configuration with threshold\n            and comparison settings.\n\n    Returns:\n        True if the threshold condition was met (error triggered),\n        False if the variable is within normal limits (OK status).\n    \"\"\"\n    if not (error_variable_conf.comparison and error_variable_conf.flag):\n        return False\n\n    op = COMPARISON_OPS.get(error_variable_conf.comparison)\n    if op and op(device_variable.processed_data, error_variable_conf.threshold):\n        return self.update_state_and_state_history(\n            timestamp=timestamp,\n            error_variable_config=error_variable_conf,\n            flag_enum=error_variable_conf.flag,\n        )\n\n    return self.update_state_and_state_history(\n        timestamp=timestamp,\n        error_variable_config=error_variable_conf,\n        flag_enum=StatusFlags.OK,\n    )\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.deserialize","title":"<code>deserialize(status_dict: dict[str, list | dict]) -&gt; Self | None</code>","text":"<p>Deserialize status state from a dictionary.</p> <p>Restores the state and state_history from previously serialized data.</p> <p>Parameters:</p> Name Type Description Default <code>status_dict</code> <code>dict[str, list | dict]</code> <p>Dictionary containing serialized state and state_history.</p> required <p>Returns:</p> Type Description <code>Self | None</code> <p>Self for method chaining.</p> Source code in <code>devices/status.py</code> <pre><code>def deserialize(self, status_dict: dict[str, list | dict]) -&gt; Self | None:\n\"\"\"Deserialize status state from a dictionary.\n\n    Restores the state and state_history from previously serialized data.\n\n    Args:\n        status_dict: Dictionary containing serialized state and state_history.\n\n    Returns:\n        Self for method chaining.\n    \"\"\"\n    if not status_dict:\n        logger.debug(\"status_dict is empty can not deserialize status\")\n        return\n    for i in self.error_variable_config_list:\n        try:\n            state_dict = next(\n                (\n                    d\n                    for d in status_dict[\"state\"]\n                    if d.get(\"error_name\") == i.error_name\n                ),\n                None,\n            )\n\n            state_history_dict = status_dict[\"state_history\"].get(i.error_name)\n            self.state_history[i.error_name] = StatusVariables(**state_history_dict)\n            self.state.append(**state_dict)\n        except Exception as e:\n            logger.debug(f\"could not restore ({i.error_name}), due to {e}\")\n        continue\n\n    return self\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.get_status_to_save","title":"<code>get_status_to_save(timestamp) -&gt; list[StatusVariables] | None</code>","text":"<p>Determine which status variables should be saved to disk.</p> <p>Status variables are saved if: - They are new (not in state_history) - Their flag has changed since last save - The save interval has elapsed since last save</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <p>Current timestamp for comparison.</p> required <p>Returns:</p> Type Description <code>list[StatusVariables] | None</code> <p>List of StatusVariables to save, sorted by error_name, or None</p> <code>list[StatusVariables] | None</code> <p>if no status needs to be saved.</p> Source code in <code>devices/status.py</code> <pre><code>def get_status_to_save(self, timestamp) -&gt; list[StatusVariables] | None:\n\"\"\"Determine which status variables should be saved to disk.\n\n    Status variables are saved if:\n    - They are new (not in state_history)\n    - Their flag has changed since last save\n    - The save interval has elapsed since last save\n\n    Args:\n        timestamp: Current timestamp for comparison.\n\n    Returns:\n        List of StatusVariables to save, sorted by error_name, or None\n        if no status needs to be saved.\n    \"\"\"\n    status_to_save = []\n    if not self.state_history:\n        for state in self.state:\n            status_to_save.append(\n                self.update_state_history_and_saving_ts(timestamp, state)\n            )\n        return sorted(\n            status_to_save, key=lambda status_to_save: status_to_save.error_name\n        )\n\n    for new_state in self.state:\n        old_state = self.state_history.get(new_state.error_name, None)\n        if not old_state:\n            status_to_save.append(\n                self.update_state_history_and_saving_ts(timestamp, new_state)\n            )\n            continue\n\n        if timestamp - old_state.last_saving_timestamp &gt; timedelta(\n            seconds=timeparse(new_state._err_var_config.save_interval)\n        ):\n            status_to_save.append(\n                self.update_state_history_and_saving_ts(timestamp, new_state)\n            )\n\n        if old_state.flag != new_state.flag:\n            status_to_save.append(\n                self.update_state_history_and_saving_ts(timestamp, new_state)\n            )\n\n    if not status_to_save:\n        return None\n    return sorted(\n        status_to_save, key=lambda status_to_save: status_to_save.error_name\n    )\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.load_error_variable_config_list","title":"<code>load_error_variable_config_list(path) -&gt; None</code>","text":"<p>Load error variable configurations from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>Path to the YAML file containing error variable configurations.</p> required <p>Returns:</p> Type Description <code>None</code> <p>List of ErrorVariablesConfig instances, or None if file not found.</p> Source code in <code>devices/status.py</code> <pre><code>def load_error_variable_config_list(self, path) -&gt; None:\n\"\"\"Load error variable configurations from a YAML file.\n\n    Args:\n        path: Path to the YAML file containing error variable configurations.\n\n    Returns:\n        List of ErrorVariablesConfig instances, or None if file not found.\n    \"\"\"\n    try:\n        with open(path, \"r\") as f:\n            data = yaml.safe_load(f)\n        return [ErrorVariablesConfig(**v) for v in data]\n    except FileNotFoundError:\n        logger.warning(f\"file={path} not found\")\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.parse_vars","title":"<code>parse_vars(vars: dict[str, DeviceVariable], timestamp: datetime) -&gt; tuple[list[StatusVariables], dict[str, DeviceVariable]] | tuple[None, None]</code>","text":"<p>Parse device variables and evaluate status conditions.</p> <p>Evaluates all device variables against their error configurations, updates the status state, and determines which status variables should be saved. Also identifies which variables triggered error conditions.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>dict[str, DeviceVariable]</code> <p>Dictionary mapping variable names to DeviceVariable instances.</p> required <code>timestamp</code> <code>datetime</code> <p>Timestamp for status evaluation.</p> required <p>Returns:</p> Type Description <code>tuple[list[StatusVariables], dict[str, DeviceVariable]] | tuple[None, None]</code> <p>Tuple of (list of StatusVariables to save, dict of triggered variables),</p> <code>tuple[list[StatusVariables], dict[str, DeviceVariable]] | tuple[None, None]</code> <p>or (None, None) if no status needs to be saved or error configs are missing.</p> Source code in <code>devices/status.py</code> <pre><code>def parse_vars(\n    self, vars: dict[str, DeviceVariable], timestamp: datetime\n) -&gt; tuple[list[StatusVariables], dict[str, DeviceVariable]] | tuple[None, None]:\n\"\"\"Parse device variables and evaluate status conditions.\n\n    Evaluates all device variables against their error configurations,\n    updates the status state, and determines which status variables\n    should be saved. Also identifies which variables triggered error\n    conditions.\n\n    Args:\n        vars: Dictionary mapping variable names to DeviceVariable instances.\n        timestamp: Timestamp for status evaluation.\n\n    Returns:\n        Tuple of (list of StatusVariables to save, dict of triggered variables),\n        or (None, None) if no status needs to be saved or error configs are missing.\n    \"\"\"\n    if not self.error_variable_config_list:\n        logger.error(\"error variable list was not provided\")\n        return None, None\n    self.state.clear()\n    triggered_vars = {}\n    for err_var_conf in self.error_variable_config_list:\n        vars_to_compare = vars.get(err_var_conf.variable_name, None)\n        if not vars_to_compare:\n            logger.debug(\n                f\"error name: {err_var_conf.error_name} not found in {vars=}\"\n            )\n            continue\n        if self.compare_vars(\n            timestamp=timestamp,\n            device_variable=vars_to_compare,\n            error_variable_conf=err_var_conf,\n        ):\n            triggered_vars[err_var_conf.variable_name] = vars_to_compare\n    status_to_save = self.get_status_to_save(timestamp=timestamp)\n    if not status_to_save:\n        return (None, None)\n    return (status_to_save, triggered_vars)\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.serialize","title":"<code>serialize() -&gt; dict[str, Any]</code>","text":"<p>Serialize the status state to a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing serialized state and state_history.</p> Source code in <code>devices/status.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize the status state to a dictionary.\n\n    Returns:\n        Dictionary containing serialized state and state_history.\n    \"\"\"\n    data = {}\n    for var in [\"state\", \"state_history\"]:\n        value = getattr(self, var, None)\n        if value is None:\n            continue\n\n        adapter = TypeAdapter(type(value))\n        data[var] = adapter.dump_python(value, mode=\"json\")\n    return data\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.update_state_and_state_history","title":"<code>update_state_and_state_history(timestamp: datetime, error_variable_config: ErrorVariablesConfig, flag_enum: StatusFlags) -&gt; bool</code>","text":"<p>Update state with a new status variable and check if flag changed.</p> <p>Creates a new StatusVariables instance, adds it to the state list, and checks if the flag has changed compared to the state history.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>datetime</code> <p>Timestamp for the new status.</p> required <code>error_variable_config</code> <code>ErrorVariablesConfig</code> <p>Error variable configuration.</p> required <code>flag_enum</code> <code>StatusFlags</code> <p>Status flag to set.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the flag matches the previous state (no change),</p> <code>bool</code> <p>False if the flag has changed or no previous state exists.</p> Source code in <code>devices/status.py</code> <pre><code>def update_state_and_state_history(\n    self,\n    timestamp: datetime,\n    error_variable_config: ErrorVariablesConfig,\n    flag_enum: StatusFlags,\n) -&gt; bool:\n\"\"\"Update state with a new status variable and check if flag changed.\n\n    Creates a new StatusVariables instance, adds it to the state list,\n    and checks if the flag has changed compared to the state history.\n\n    Args:\n        timestamp: Timestamp for the new status.\n        error_variable_config: Error variable configuration.\n        flag_enum: Status flag to set.\n\n    Returns:\n        True if the flag matches the previous state (no change),\n        False if the flag has changed or no previous state exists.\n    \"\"\"\n    status_obj = StatusVariables(\n        error_name=error_variable_config.error_name,\n        flag=flag_enum,\n        description=error_variable_config.description,\n        timestamp=timestamp,\n    )\n    status_obj._err_var_config = error_variable_config\n    self.state.append(status_obj)\n\n    if not self.state_history:\n        return True\n\n    old_state = self.state_history.get(error_variable_config.error_name, None)\n    if not old_state or old_state.flag != status_obj.flag:\n        return False\n    return True\n</code></pre>"},{"location":"api/devices/status/#devices.status.Status.update_state_history_and_saving_ts","title":"<code>update_state_history_and_saving_ts(timestamp, new_state: StatusVariables) -&gt; StatusVariables</code>","text":"<p>Update state history with a new state and set its saving timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <p>Timestamp to set as the last saving timestamp.</p> required <code>new_state</code> <code>StatusVariables</code> <p>StatusVariables instance to save to history.</p> required <p>Returns:</p> Type Description <code>StatusVariables</code> <p>The updated StatusVariables instance with last_saving_timestamp set.</p> Source code in <code>devices/status.py</code> <pre><code>def update_state_history_and_saving_ts(\n    self, timestamp, new_state: StatusVariables\n) -&gt; StatusVariables:\n\"\"\"Update state history with a new state and set its saving timestamp.\n\n    Args:\n        timestamp: Timestamp to set as the last saving timestamp.\n        new_state: StatusVariables instance to save to history.\n\n    Returns:\n        The updated StatusVariables instance with last_saving_timestamp set.\n    \"\"\"\n    new_state.last_saving_timestamp = timestamp\n    self.state_history[new_state.error_name] = new_state\n    return new_state\n</code></pre>"},{"location":"api/devices/status/#functions","title":"Functions","text":""},{"location":"api/devices/status/#convert_datetime_to_iso","title":"convert_datetime_to_iso","text":"<p>Convert a datetime object to ISO format string.</p> <p>Parameters:</p> Name Type Description Default <code>ts</code> <code>datetime</code> <p>Datetime object to convert.</p> required <p>Returns:</p> Type Description <p>ISO format string representation of the datetime.</p> Source code in <code>devices/status.py</code> <pre><code>def convert_datetime_to_iso(ts: datetime):\n\"\"\"Convert a datetime object to ISO format string.\n\n    Args:\n        ts: Datetime object to convert.\n\n    Returns:\n        ISO format string representation of the datetime.\n    \"\"\"\n    return ts.isoformat()\n</code></pre>"},{"location":"api/devices/status/#variables","title":"Variables","text":""},{"location":"api/devices/status/#devices.status.COMPARISON_OPS","title":"<code>devices.status.COMPARISON_OPS = {Comparisons.EQUAL: operator.eq, Comparisons.EQUAL_OR_GREATER: operator.ge, Comparisons.EQUAL_OR_LESS: operator.le, Comparisons.LESS_THAN: operator.lt, Comparisons.GREATER_THAN: operator.gt, Comparisons.AND: operator.and_}</code>  <code>module-attribute</code>","text":"<p>Mapping of Comparisons enum values to Python operator functions.</p>"},{"location":"api/devices/interfaces/modbusRTU/","title":"devices.interfaces.modbusRTU","text":""},{"location":"api/devices/interfaces/modbusRTU/#classes","title":"Classes","text":""},{"location":"api/devices/interfaces/modbusRTU/#modbusrtu","title":"ModbusRtu","text":"Source code in <code>devices/interfaces/modbusRTU.py</code> <pre><code>@register_interface\nclass ModbusRtu:\n    def __init__(\n        self,\n        port=\"/dev/ttyACM0\",\n        timeout=2,\n        retries=3,\n        baudrate=115200,\n        bytesize=8,\n        parity=\"N\",\n        stopbits=1,\n    ) -&gt; None:\n        self.port = port\n        self.timeout = timeout\n        self.retries = retries\n        self.baudrate = baudrate\n        self.bytesize = bytesize\n        self.parity = parity\n        self.stopbits = stopbits\n        self.client = AsyncModbusSerialClient(\n            port=self.port,\n            baudrate=self.baudrate,\n            retries=self.retries,\n            timeout=self.timeout,\n            bytesize=self.bytesize,\n            parity=self.parity,\n            stopbits=self.stopbits,\n        )\n        self.connection_attempts = 0\n\n    async def init_connection(self) -&gt; None:\n        if not self.check_connection():\n            await self.client.connect()\n        if self.check_connection():\n            logger.info(\"Modbus connected\")\n        return None\n\n    async def read_data(self, address: int, count: int) -&gt; list[int]:\n        try:\n            result = await self.client.read_holding_registers(\n                address=address, count=count\n            )\n\n            return result.registers\n        except Exception as e:\n            logger.warning(f\"error ({e}) reading {address=}\")\n            return []\n\n    async def close_connection(self) -&gt; None:\n        if not self.client.connected:\n            logger.warning(\"Modbus connection is already closed\")\n            return\n        self.client.close()\n        logger.warning(\"Modbus connection is closed\")\n\n    def check_connection(self) -&gt; bool:\n        return self.client.connected\n</code></pre>"},{"location":"api/external_api/epever/epever_devices/","title":"external_api.epever.epever_devices","text":""},{"location":"api/external_api/epever/epever_devices/#classes","title":"Classes","text":""},{"location":"api/external_api/epever/epever_devices/#epeverinverter","title":"EpeverInverter","text":"<p>               Bases: <code>Device</code></p> <p>Device implementation for Epever AHP20SA series inverters.</p> <p>This class handles communication with Epever inverters via Modbus RTU, reading register data and converting it to structured variable objects. Variable configurations are loaded from YAML files and used to interpret raw register values.</p> <p>Attributes:</p> Name Type Description <code>DEVICE_MATCH</code> <code>list[str]</code> <p>List of device type identifiers for factory registration.</p> <code>device_variables_confs</code> <code>dict[str, EpeverVariablesConfs]</code> <p>Dictionary mapping variable names to their configuration objects.</p> Source code in <code>external_api/epever/epever_devices.py</code> <pre><code>@register_device\nclass EpeverInverter(Device):\n\"\"\"Device implementation for Epever AHP20SA series inverters.\n\n    This class handles communication with Epever inverters via Modbus RTU,\n    reading register data and converting it to structured variable objects.\n    Variable configurations are loaded from YAML files and used to interpret\n    raw register values.\n\n    Attributes:\n        DEVICE_MATCH: List of device type identifiers for factory registration.\n        device_variables_confs: Dictionary mapping variable names to their\n            configuration objects.\n    \"\"\"\n\n    DEVICE_MATCH: list[str] = [\"Epever_AHP20SA_series_inverter\"]\n\"\"\"List of device type identifiers for factory registration.\"\"\"\n\n    def __init__(self, id, environment, interface, device_conf, api=None):\n\"\"\"Initialize an EpeverInverter device instance.\n\n        Args:\n            id: Unique identifier for the device.\n            environment: Environment instance providing configuration and context.\n            interface: Interface instance for Modbus communication.\n            device_conf: Device configuration object containing device-specific\n                settings including the path to variable configuration file.\n            api: Optional DeviceApi instance for external API interactions.\n                Defaults to None.\n        \"\"\"\n        super().__init__(id, environment, interface, device_conf, api)\n        self.device_variables_confs: dict[\n            str, EpeverVariablesConfs\n        ] = self.load_device_variables_confs(\n            path=self.device_conf.device_variables_path\n        )\n\n    def load_device_variables_confs(self, path) -&gt; dict[str, EpeverVariablesConfs]:\n\"\"\"Load variable configurations from a YAML file.\n\n        Reads a YAML configuration file containing variable definitions and\n        converts them to EpeverVariablesConfs objects. Each variable definition\n        includes register addresses, data types, scaling coefficients, and\n        other interpretation parameters.\n\n        Args:\n            path: File path to the YAML configuration file containing variable\n                definitions.\n\n        Returns:\n            Dictionary mapping variable names to their EpeverVariablesConfs\n            configuration objects. Returns an empty dictionary if the file\n            is not found.\n        \"\"\"\n        try:\n            with open(path, \"r\") as f:\n                data = yaml.safe_load(f)\n            return {k: EpeverVariablesConfs(**v) for k, v in data.items()}\n        except FileNotFoundError:\n            logger.warning(\n                f\"file={path} not found \\n {self.__class__.__name__} device object will not be created\"\n            )\n            return dict()\n\n    @classmethod\n    def _from_device_conf(\n        cls, id: str, environment: \"env.Environment\", device_conf\n    ) -&gt; \"EpeverInverter | None\":\n\"\"\"Create an EpeverInverter instance from device configuration.\n\n        Factory method that creates and initializes an EpeverInverter device\n        from configuration. It resolves the interface class, creates the interface\n        instance, and validates that variable configurations were loaded successfully.\n\n        Args:\n            id: Unique identifier for the device.\n            environment: Environment instance providing configuration and context.\n            device_conf: Device configuration object containing device settings\n                including interface name and variable configuration path.\n\n        Returns:\n            An initialized EpeverInverter instance if successful, None if the\n            interface is not found or variable configurations could not be loaded.\n        \"\"\"\n        interface_cls = get_interface_cls(interface_name=device_conf.interface)\n        if interface_cls is None:\n            logger.warning(\n                f\"interface: {device_conf.interface}, not found for {device_conf.name}\"\n            )\n            return None\n        interface = interface_cls()\n        epever_inverter_obj = cls(id, environment, interface, device_conf)\n        if not epever_inverter_obj.device_variables_confs:\n            return None\n        return epever_inverter_obj\n\n    async def _get_vars(\n        self, timestamp: datetime\n    ) -&gt; dict[str, EpeverVariableObject] | None:\n\"\"\"Retrieve all device variables by reading Modbus registers.\n\n        This method implements the device-specific variable retrieval logic.\n        It establishes a connection to the device, reads all configured Modbus\n        registers, interprets the raw data using appropriate variable object\n        classes, and returns a dictionary of processed variable objects.\n\n        The method handles:\n        - Connection initialization and validation\n        - Reading registers for each configured variable\n        - Combining multi-word registers (high_word/low_word) when needed\n        - Creating variable objects using the factory pattern\n        - Error handling and logging for failed reads\n        - Connection cleanup\n\n        Args:\n            timestamp: Timestamp to associate with all retrieved variable values.\n\n        Returns:\n            Dictionary mapping variable names to their EpeverVariableObject\n            instances containing processed register data. Returns None if the\n            connection cannot be established.\n\n        Raises:\n            Any exceptions raised during register reading are caught and logged,\n            with processing continuing for remaining variables.\n        \"\"\"\n        await self.interface.init_connection()\n        results = {}\n        if not self.interface.check_connection():\n            logger.error(\n                f\"unable to establish a connection to {self.device_conf.interface}\"\n            )\n            return None\n\n        logger.info(\"reading all registers\")\n        for variable, variable_confs in self.device_variables_confs.items():\n            logger.debug(f\"reading {variable} register\")\n\n            try:\n                registers = await self.interface.read_data(\n                    address=variable_confs.address, count=variable_confs.count\n                )\n            except Exception:\n                logger.exception(\n                    f\"Failed to read data on interface {self.interface} for variable {variable}\"\n                )\n                continue\n\n            if not registers:\n                logger.warning(f\"Could not read data for {variable}\")\n                continue\n\n            if variable_confs.low_word and variable_confs.high_word:\n                raw_data = (\n                    registers[variable_confs.high_word] &lt;&lt; 16\n                ) | variable_confs.low_word\n            else:\n                raw_data = registers[0]\n\n            cls = get_variable_cls(variable_name=variable_confs.variable_type)\n\n            if not cls:\n                logger.warning(\n                    f\"Data variable {variable_confs.variable_type} class not found for {variable} \"\n                )\n                continue\n\n            try:\n                variable_obj = cls.from_register(\n                    variable_name=variable,\n                    raw_data=raw_data,\n                    timestamp=timestamp,\n                    variable_confs=variable_confs,\n                )\n            except Exception as e:\n                logger.exception(\n                    f\"Failed to create variable object for {variable}, ({e})\"\n                )\n                continue\n            results[variable] = variable_obj\n\n        await self.interface.close_connection()\n        return results\n</code></pre>"},{"location":"api/external_api/epever/epever_devices/#external_api.epever.epever_devices.EpeverInverter.DEVICE_MATCH","title":"<code>DEVICE_MATCH: list[str] = ['Epever_AHP20SA_series_inverter']</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of device type identifiers for factory registration.</p>"},{"location":"api/external_api/epever/epever_devices/#external_api.epever.epever_devices.EpeverInverter.__init__","title":"<code>__init__(id, environment, interface, device_conf, api=None)</code>","text":"<p>Initialize an EpeverInverter device instance.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>Unique identifier for the device.</p> required <code>environment</code> <p>Environment instance providing configuration and context.</p> required <code>interface</code> <p>Interface instance for Modbus communication.</p> required <code>device_conf</code> <p>Device configuration object containing device-specific settings including the path to variable configuration file.</p> required <code>api</code> <p>Optional DeviceApi instance for external API interactions. Defaults to None.</p> <code>None</code> Source code in <code>external_api/epever/epever_devices.py</code> <pre><code>def __init__(self, id, environment, interface, device_conf, api=None):\n\"\"\"Initialize an EpeverInverter device instance.\n\n    Args:\n        id: Unique identifier for the device.\n        environment: Environment instance providing configuration and context.\n        interface: Interface instance for Modbus communication.\n        device_conf: Device configuration object containing device-specific\n            settings including the path to variable configuration file.\n        api: Optional DeviceApi instance for external API interactions.\n            Defaults to None.\n    \"\"\"\n    super().__init__(id, environment, interface, device_conf, api)\n    self.device_variables_confs: dict[\n        str, EpeverVariablesConfs\n    ] = self.load_device_variables_confs(\n        path=self.device_conf.device_variables_path\n    )\n</code></pre>"},{"location":"api/external_api/epever/epever_devices/#external_api.epever.epever_devices.EpeverInverter.load_device_variables_confs","title":"<code>load_device_variables_confs(path) -&gt; dict[str, EpeverVariablesConfs]</code>","text":"<p>Load variable configurations from a YAML file.</p> <p>Reads a YAML configuration file containing variable definitions and converts them to EpeverVariablesConfs objects. Each variable definition includes register addresses, data types, scaling coefficients, and other interpretation parameters.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>File path to the YAML configuration file containing variable definitions.</p> required <p>Returns:</p> Type Description <code>dict[str, EpeverVariablesConfs]</code> <p>Dictionary mapping variable names to their EpeverVariablesConfs</p> <code>dict[str, EpeverVariablesConfs]</code> <p>configuration objects. Returns an empty dictionary if the file</p> <code>dict[str, EpeverVariablesConfs]</code> <p>is not found.</p> Source code in <code>external_api/epever/epever_devices.py</code> <pre><code>def load_device_variables_confs(self, path) -&gt; dict[str, EpeverVariablesConfs]:\n\"\"\"Load variable configurations from a YAML file.\n\n    Reads a YAML configuration file containing variable definitions and\n    converts them to EpeverVariablesConfs objects. Each variable definition\n    includes register addresses, data types, scaling coefficients, and\n    other interpretation parameters.\n\n    Args:\n        path: File path to the YAML configuration file containing variable\n            definitions.\n\n    Returns:\n        Dictionary mapping variable names to their EpeverVariablesConfs\n        configuration objects. Returns an empty dictionary if the file\n        is not found.\n    \"\"\"\n    try:\n        with open(path, \"r\") as f:\n            data = yaml.safe_load(f)\n        return {k: EpeverVariablesConfs(**v) for k, v in data.items()}\n    except FileNotFoundError:\n        logger.warning(\n            f\"file={path} not found \\n {self.__class__.__name__} device object will not be created\"\n        )\n        return dict()\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/","title":"external_api.epever.epever_objects","text":""},{"location":"api/external_api/epever/epever_objects/#classes","title":"Classes","text":""},{"location":"api/external_api/epever/epever_objects/#epevervariablesconfs","title":"EpeverVariablesConfs","text":"<p>               Bases: <code>VariablesConfs</code></p> <p>Configuration settings for Epever device variables.</p> <p>Extends VariablesConfs with Epever-specific configuration options for interpreting Modbus register data, including address mapping, coefficient scaling, bit extraction, and value mapping.</p> <p>Attributes:</p> Name Type Description <code>variable_type</code> <code>str</code> <p>Type identifier for the variable class to use.</p> <code>address</code> <code>int</code> <p>Modbus register address for this variable.</p> <code>count</code> <code>int</code> <p>Number of registers to read. Defaults to 1.</p> <code>low_word</code> <code>int | None</code> <p>Low word value for multi-word registers. Defaults to None.</p> <code>high_word</code> <code>int | None</code> <p>High word value for multi-word registers. Defaults to None.</p> <code>coefficient</code> <code>int</code> <p>Scaling coefficient to apply to raw register values. Defaults to 1.</p> <code>unit</code> <code>str | None</code> <p>Unit of measurement for the variable (e.g., \"V\", \"A\", \"W\"). Defaults to None.</p> <code>mapping</code> <code>dict[int, str] | None</code> <p>Dictionary mapping numeric values to string representations. Used for status codes and enumerated values. Defaults to None.</p> <code>start_bit</code> <code>int | None</code> <p>Starting bit position for bit extraction. Defaults to None.</p> <code>end_bit</code> <code>int | None</code> <p>Ending bit position for bit extraction. Defaults to None.</p> <code>bit</code> <code>int | None</code> <p>Single bit position for one-bit extraction. Defaults to None.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>class EpeverVariablesConfs(VariablesConfs):\n\"\"\"Configuration settings for Epever device variables.\n\n    Extends VariablesConfs with Epever-specific configuration options for\n    interpreting Modbus register data, including address mapping, coefficient\n    scaling, bit extraction, and value mapping.\n\n    Attributes:\n        variable_type: Type identifier for the variable class to use.\n        address: Modbus register address for this variable.\n        count: Number of registers to read. Defaults to 1.\n        low_word: Low word value for multi-word registers. Defaults to None.\n        high_word: High word value for multi-word registers. Defaults to None.\n        coefficient: Scaling coefficient to apply to raw register values.\n            Defaults to 1.\n        unit: Unit of measurement for the variable (e.g., \"V\", \"A\", \"W\").\n            Defaults to None.\n        mapping: Dictionary mapping numeric values to string representations.\n            Used for status codes and enumerated values. Defaults to None.\n        start_bit: Starting bit position for bit extraction. Defaults to None.\n        end_bit: Ending bit position for bit extraction. Defaults to None.\n        bit: Single bit position for one-bit extraction. Defaults to None.\n    \"\"\"\n\n    variable_type: str\n    address: int\n    count: int = 1\n    low_word: int | None = None\n    high_word: int | None = None\n    coefficient: int = 1\n    unit: str | None = None\n    mapping: dict[int, str] | None = None\n    start_bit: int | None = None\n    end_bit: int | None = None\n    bit: int | None = None\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#epevervariableobject","title":"EpeverVariableObject","text":"<p>               Bases: <code>DeviceVariable</code></p> <p>Base class for Epever variable objects that interpret Modbus register data.</p> <p>This class provides the core functionality for processing raw Modbus register values from Epever inverters. Subclasses must implement <code>interpret_register()</code> to define how raw register data is converted to meaningful values.</p> <p>Attributes:</p> Name Type Description <code>_variable_confs</code> <code>VariablesConfs</code> <p>EpeverVariablesConfs instance containing configuration for this variable.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>class EpeverVariableObject(DeviceVariable):\n\"\"\"Base class for Epever variable objects that interpret Modbus register data.\n\n    This class provides the core functionality for processing raw Modbus register\n    values from Epever inverters. Subclasses must implement `interpret_register()`\n    to define how raw register data is converted to meaningful values.\n\n    Attributes:\n        _variable_confs: EpeverVariablesConfs instance containing configuration\n            for this variable.\n    \"\"\"\n\n    def interpret_register(self) -&gt; str | int | float:\n\"\"\"Interpret raw register data into a processed value.\n\n        This method must be implemented by subclasses to define how raw register\n        data is converted to the appropriate data type (string, int, or float).\n\n        Returns:\n            The interpreted value as a string, integer, or float.\n\n        Raises:\n            NotImplementedError: If not implemented by subclass.\n        \"\"\"\n        ...\n\n    def extract_bits(self, value, start_bit, end_bit=None):\n\"\"\"Extract bits from a value within a specified bit range.\n\n        Args:\n            value: The integer value to extract bits from.\n            start_bit: Starting bit position (0-indexed from LSB).\n            end_bit: Ending bit position (inclusive). If None, extracts a\n                single bit at start_bit. Defaults to None.\n\n        Returns:\n            The extracted bit value as an integer. If end_bit is None,\n            returns 0 or 1. Otherwise, returns the value of the bit range.\n        \"\"\"\n        if end_bit is None:\n            return (value &gt;&gt; start_bit) &amp; 1\n        mask = (1 &lt;&lt; (end_bit - start_bit + 1)) - 1\n        return (value &gt;&gt; start_bit) &amp; mask\n\n    def coeff_value(self, flt=False) -&gt; int | float:\n\"\"\"Apply coefficient scaling to raw data.\n\n        Divides the raw register data by the coefficient to get the actual\n        physical value. The coefficient is used to scale integer register\n        values to their real-world units.\n\n        Args:\n            flt: If True, returns a float rounded to 2 decimal places.\n                If False, returns an integer. Defaults to False.\n\n        Returns:\n            The scaled value as an integer or float, depending on the flt\n            parameter.\n        \"\"\"\n        if flt:\n            return round(self.raw_data / self._variable_confs.coefficient, 2)\n        return int(self.raw_data / self._variable_confs.coefficient)\n\n    @classmethod\n    def from_register(\n        cls,\n        variable_name: str,\n        raw_data: int,\n        timestamp: datetime,\n        variable_confs: EpeverVariablesConfs,\n    ) -&gt; Self:\n\"\"\"Create an EpeverVariableObject instance from Modbus register data.\n\n        Factory method that creates and initializes a variable object from raw\n        register data, automatically processing the data according to the\n        variable configuration.\n\n        Args:\n            variable_name: Name identifier for this variable.\n            raw_data: Raw integer value read from the Modbus register.\n            timestamp: Timestamp when the data was read.\n            variable_confs: EpeverVariablesConfs instance containing\n                configuration for interpreting the register data.\n\n        Returns:\n            An initialized EpeverVariableObject instance with processed data.\n        \"\"\"\n        obj = cls(\n            variable_name=variable_name,\n            raw_data=raw_data,\n            unit=variable_confs.unit,\n            timestamp=timestamp,\n        )\n        obj._variable_confs = variable_confs\n        obj.process_data()\n        return obj\n\n    def pretty_print(self) -&gt; str:\n\"\"\"Generate a human-readable string representation of the variable.\n\n        Formats the raw data value with its unit of measurement if available.\n\n        Returns:\n            A formatted string containing the raw data value and unit,\n            or just the raw data value if no unit is configured.\n        \"\"\"\n        if self._variable_confs.unit:\n            return f\"{self.raw_data} {self._variable_confs.unit}\"\n        return self.raw_data\n\n    def process_data(self) -&gt; None:\n\"\"\"Process raw register data into interpreted value.\n\n        Calls `interpret_register()` to convert raw data to processed data\n        and stores the result in `processed_data`.\n        \"\"\"\n        self.processed_data = self.interpret_register()\n        return None\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.EpeverVariableObject.coeff_value","title":"<code>coeff_value(flt=False) -&gt; int | float</code>","text":"<p>Apply coefficient scaling to raw data.</p> <p>Divides the raw register data by the coefficient to get the actual physical value. The coefficient is used to scale integer register values to their real-world units.</p> <p>Parameters:</p> Name Type Description Default <code>flt</code> <p>If True, returns a float rounded to 2 decimal places. If False, returns an integer. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>int | float</code> <p>The scaled value as an integer or float, depending on the flt</p> <code>int | float</code> <p>parameter.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def coeff_value(self, flt=False) -&gt; int | float:\n\"\"\"Apply coefficient scaling to raw data.\n\n    Divides the raw register data by the coefficient to get the actual\n    physical value. The coefficient is used to scale integer register\n    values to their real-world units.\n\n    Args:\n        flt: If True, returns a float rounded to 2 decimal places.\n            If False, returns an integer. Defaults to False.\n\n    Returns:\n        The scaled value as an integer or float, depending on the flt\n        parameter.\n    \"\"\"\n    if flt:\n        return round(self.raw_data / self._variable_confs.coefficient, 2)\n    return int(self.raw_data / self._variable_confs.coefficient)\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.EpeverVariableObject.extract_bits","title":"<code>extract_bits(value, start_bit, end_bit=None)</code>","text":"<p>Extract bits from a value within a specified bit range.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The integer value to extract bits from.</p> required <code>start_bit</code> <p>Starting bit position (0-indexed from LSB).</p> required <code>end_bit</code> <p>Ending bit position (inclusive). If None, extracts a single bit at start_bit. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>The extracted bit value as an integer. If end_bit is None,</p> <p>returns 0 or 1. Otherwise, returns the value of the bit range.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def extract_bits(self, value, start_bit, end_bit=None):\n\"\"\"Extract bits from a value within a specified bit range.\n\n    Args:\n        value: The integer value to extract bits from.\n        start_bit: Starting bit position (0-indexed from LSB).\n        end_bit: Ending bit position (inclusive). If None, extracts a\n            single bit at start_bit. Defaults to None.\n\n    Returns:\n        The extracted bit value as an integer. If end_bit is None,\n        returns 0 or 1. Otherwise, returns the value of the bit range.\n    \"\"\"\n    if end_bit is None:\n        return (value &gt;&gt; start_bit) &amp; 1\n    mask = (1 &lt;&lt; (end_bit - start_bit + 1)) - 1\n    return (value &gt;&gt; start_bit) &amp; mask\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.EpeverVariableObject.from_register","title":"<code>from_register(variable_name: str, raw_data: int, timestamp: datetime, variable_confs: EpeverVariablesConfs) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Create an EpeverVariableObject instance from Modbus register data.</p> <p>Factory method that creates and initializes a variable object from raw register data, automatically processing the data according to the variable configuration.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>Name identifier for this variable.</p> required <code>raw_data</code> <code>int</code> <p>Raw integer value read from the Modbus register.</p> required <code>timestamp</code> <code>datetime</code> <p>Timestamp when the data was read.</p> required <code>variable_confs</code> <code>EpeverVariablesConfs</code> <p>EpeverVariablesConfs instance containing configuration for interpreting the register data.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An initialized EpeverVariableObject instance with processed data.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@classmethod\ndef from_register(\n    cls,\n    variable_name: str,\n    raw_data: int,\n    timestamp: datetime,\n    variable_confs: EpeverVariablesConfs,\n) -&gt; Self:\n\"\"\"Create an EpeverVariableObject instance from Modbus register data.\n\n    Factory method that creates and initializes a variable object from raw\n    register data, automatically processing the data according to the\n    variable configuration.\n\n    Args:\n        variable_name: Name identifier for this variable.\n        raw_data: Raw integer value read from the Modbus register.\n        timestamp: Timestamp when the data was read.\n        variable_confs: EpeverVariablesConfs instance containing\n            configuration for interpreting the register data.\n\n    Returns:\n        An initialized EpeverVariableObject instance with processed data.\n    \"\"\"\n    obj = cls(\n        variable_name=variable_name,\n        raw_data=raw_data,\n        unit=variable_confs.unit,\n        timestamp=timestamp,\n    )\n    obj._variable_confs = variable_confs\n    obj.process_data()\n    return obj\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.EpeverVariableObject.interpret_register","title":"<code>interpret_register() -&gt; str | int | float</code>","text":"<p>Interpret raw register data into a processed value.</p> <p>This method must be implemented by subclasses to define how raw register data is converted to the appropriate data type (string, int, or float).</p> <p>Returns:</p> Type Description <code>str | int | float</code> <p>The interpreted value as a string, integer, or float.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If not implemented by subclass.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; str | int | float:\n\"\"\"Interpret raw register data into a processed value.\n\n    This method must be implemented by subclasses to define how raw register\n    data is converted to the appropriate data type (string, int, or float).\n\n    Returns:\n        The interpreted value as a string, integer, or float.\n\n    Raises:\n        NotImplementedError: If not implemented by subclass.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.EpeverVariableObject.pretty_print","title":"<code>pretty_print() -&gt; str</code>","text":"<p>Generate a human-readable string representation of the variable.</p> <p>Formats the raw data value with its unit of measurement if available.</p> <p>Returns:</p> Type Description <code>str</code> <p>A formatted string containing the raw data value and unit,</p> <code>str</code> <p>or just the raw data value if no unit is configured.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def pretty_print(self) -&gt; str:\n\"\"\"Generate a human-readable string representation of the variable.\n\n    Formats the raw data value with its unit of measurement if available.\n\n    Returns:\n        A formatted string containing the raw data value and unit,\n        or just the raw data value if no unit is configured.\n    \"\"\"\n    if self._variable_confs.unit:\n        return f\"{self.raw_data} {self._variable_confs.unit}\"\n    return self.raw_data\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.EpeverVariableObject.process_data","title":"<code>process_data() -&gt; None</code>","text":"<p>Process raw register data into interpreted value.</p> <p>Calls <code>interpret_register()</code> to convert raw data to processed data and stores the result in <code>processed_data</code>.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def process_data(self) -&gt; None:\n\"\"\"Process raw register data into interpreted value.\n\n    Calls `interpret_register()` to convert raw data to processed data\n    and stores the result in `processed_data`.\n    \"\"\"\n    self.processed_data = self.interpret_register()\n    return None\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#startandendbit","title":"StartAndEndBit","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for extracting a bit range and mapping to string values.</p> <p>Extracts a range of bits from the register value (using start_bit and end_bit) and maps the resulting integer to a string representation using the configured mapping dictionary.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass StartAndEndBit(EpeverVariableObject):\n\"\"\"Variable object for extracting a bit range and mapping to string values.\n\n    Extracts a range of bits from the register value (using start_bit and\n    end_bit) and maps the resulting integer to a string representation\n    using the configured mapping dictionary.\n    \"\"\"\n\n    def interpret_register(self) -&gt; str:\n\"\"\"Interpret register by extracting bit range and mapping to string.\n\n        Returns:\n            The mapped string value from the configuration, or \"Unknown (value)\"\n            if no mapping is configured or the value is not in the mapping.\n        \"\"\"\n        value = self.extract_bits(\n            self.coeff_value(),\n            self._variable_confs.start_bit,\n            self._variable_confs.end_bit,\n        )\n        if not self._variable_confs.mapping:\n            logger.warning(f\"Missing mapping conf for {self.variable_name}\")\n            return f\"Unknown ({value})\"\n        return self._variable_confs.mapping.get(value, f\"Unknown ({value})\")\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.StartAndEndBit.interpret_register","title":"<code>interpret_register() -&gt; str</code>","text":"<p>Interpret register by extracting bit range and mapping to string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The mapped string value from the configuration, or \"Unknown (value)\"</p> <code>str</code> <p>if no mapping is configured or the value is not in the mapping.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; str:\n\"\"\"Interpret register by extracting bit range and mapping to string.\n\n    Returns:\n        The mapped string value from the configuration, or \"Unknown (value)\"\n        if no mapping is configured or the value is not in the mapping.\n    \"\"\"\n    value = self.extract_bits(\n        self.coeff_value(),\n        self._variable_confs.start_bit,\n        self._variable_confs.end_bit,\n    )\n    if not self._variable_confs.mapping:\n        logger.warning(f\"Missing mapping conf for {self.variable_name}\")\n        return f\"Unknown ({value})\"\n    return self._variable_confs.mapping.get(value, f\"Unknown ({value})\")\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#onebitstrvariable","title":"oneBitStrVariable","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for extracting a single bit and mapping to string values.</p> <p>Extracts a single bit from the register value (using the bit configuration) and maps the resulting 0 or 1 value to a string representation using the configured mapping dictionary.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass oneBitStrVariable(EpeverVariableObject):\n\"\"\"Variable object for extracting a single bit and mapping to string values.\n\n    Extracts a single bit from the register value (using the bit configuration)\n    and maps the resulting 0 or 1 value to a string representation using\n    the configured mapping dictionary.\n    \"\"\"\n\n    def interpret_register(self) -&gt; str:\n\"\"\"Interpret register by extracting single bit and mapping to string.\n\n        Returns:\n            The mapped string value from the configuration, or \"Unknown (value)\"\n            if no mapping is configured or the value is not in the mapping.\n        \"\"\"\n        value = self.extract_bits(self.coeff_value(), self._variable_confs.bit)\n        if not self._variable_confs.mapping:\n            logger.warning(f\"Missing mapping conf for {self.variable_name}\")\n            return f\"Unknown ({value})\"\n        return self._variable_confs.mapping.get(value, f\"Unknown ({value})\")\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.oneBitStrVariable.interpret_register","title":"<code>interpret_register() -&gt; str</code>","text":"<p>Interpret register by extracting single bit and mapping to string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The mapped string value from the configuration, or \"Unknown (value)\"</p> <code>str</code> <p>if no mapping is configured or the value is not in the mapping.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; str:\n\"\"\"Interpret register by extracting single bit and mapping to string.\n\n    Returns:\n        The mapped string value from the configuration, or \"Unknown (value)\"\n        if no mapping is configured or the value is not in the mapping.\n    \"\"\"\n    value = self.extract_bits(self.coeff_value(), self._variable_confs.bit)\n    if not self._variable_confs.mapping:\n        logger.warning(f\"Missing mapping conf for {self.variable_name}\")\n        return f\"Unknown ({value})\"\n    return self._variable_confs.mapping.get(value, f\"Unknown ({value})\")\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#standardfloatvariable","title":"StandardFloatVariable","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for standard unsigned float values.</p> <p>Interprets register data as an unsigned floating-point value by applying the coefficient scaling and returning a float rounded to 2 decimal places.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass StandardFloatVariable(EpeverVariableObject):\n\"\"\"Variable object for standard unsigned float values.\n\n    Interprets register data as an unsigned floating-point value by applying\n    the coefficient scaling and returning a float rounded to 2 decimal places.\n    \"\"\"\n\n    def interpret_register(self) -&gt; float:\n\"\"\"Interpret register as unsigned float value.\n\n        Returns:\n            The scaled float value rounded to 2 decimal places.\n        \"\"\"\n        return self.coeff_value(flt=True)\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.StandardFloatVariable.interpret_register","title":"<code>interpret_register() -&gt; float</code>","text":"<p>Interpret register as unsigned float value.</p> <p>Returns:</p> Type Description <code>float</code> <p>The scaled float value rounded to 2 decimal places.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; float:\n\"\"\"Interpret register as unsigned float value.\n\n    Returns:\n        The scaled float value rounded to 2 decimal places.\n    \"\"\"\n    return self.coeff_value(flt=True)\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#standardfloatvariablesigned","title":"StandardFloatVariableSigned","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for signed float values.</p> <p>Interprets register data as a signed floating-point value using two's complement representation. Values with the MSB (bit 15) set are treated as negative numbers.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass StandardFloatVariableSigned(EpeverVariableObject):\n\"\"\"Variable object for signed float values.\n\n    Interprets register data as a signed floating-point value using two's\n    complement representation. Values with the MSB (bit 15) set are treated\n    as negative numbers.\n    \"\"\"\n\n    def interpret_register(self) -&gt; float:\n\"\"\"Interpret register as signed float value.\n\n        Checks if the most significant bit (bit 15) is set to determine\n        if the value is negative, then applies two's complement conversion\n        and coefficient scaling.\n\n        Returns:\n            The scaled signed float value rounded to 2 decimal places.\n        \"\"\"\n        if self.raw_data &amp; 32768 == 32768:\n            signed_number = self.raw_data - 65536\n            return signed_number / self._variable_confs.coefficient\n        return self.coeff_value(flt=True)\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.StandardFloatVariableSigned.interpret_register","title":"<code>interpret_register() -&gt; float</code>","text":"<p>Interpret register as signed float value.</p> <p>Checks if the most significant bit (bit 15) is set to determine if the value is negative, then applies two's complement conversion and coefficient scaling.</p> <p>Returns:</p> Type Description <code>float</code> <p>The scaled signed float value rounded to 2 decimal places.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; float:\n\"\"\"Interpret register as signed float value.\n\n    Checks if the most significant bit (bit 15) is set to determine\n    if the value is negative, then applies two's complement conversion\n    and coefficient scaling.\n\n    Returns:\n        The scaled signed float value rounded to 2 decimal places.\n    \"\"\"\n    if self.raw_data &amp; 32768 == 32768:\n        signed_number = self.raw_data - 65536\n        return signed_number / self._variable_confs.coefficient\n    return self.coeff_value(flt=True)\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#standardintvariable","title":"StandardIntVariable","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for standard unsigned integer values.</p> <p>Interprets register data as an unsigned integer value by applying the coefficient scaling and returning an integer.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass StandardIntVariable(EpeverVariableObject):\n\"\"\"Variable object for standard unsigned integer values.\n\n    Interprets register data as an unsigned integer value by applying\n    the coefficient scaling and returning an integer.\n    \"\"\"\n\n    def interpret_register(self) -&gt; int:\n\"\"\"Interpret register as unsigned integer value.\n\n        Returns:\n            The scaled integer value.\n        \"\"\"\n        return int(self.coeff_value(flt=False))\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.StandardIntVariable.interpret_register","title":"<code>interpret_register() -&gt; int</code>","text":"<p>Interpret register as unsigned integer value.</p> <p>Returns:</p> Type Description <code>int</code> <p>The scaled integer value.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; int:\n\"\"\"Interpret register as unsigned integer value.\n\n    Returns:\n        The scaled integer value.\n    \"\"\"\n    return int(self.coeff_value(flt=False))\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#standardintvariablesigned","title":"StandardIntVariableSigned","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for signed integer values.</p> <p>Interprets register data as a signed integer value using two's complement representation. Values with the MSB (bit 15) set are treated as negative numbers.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass StandardIntVariableSigned(EpeverVariableObject):\n\"\"\"Variable object for signed integer values.\n\n    Interprets register data as a signed integer value using two's complement\n    representation. Values with the MSB (bit 15) set are treated as negative\n    numbers.\n    \"\"\"\n\n    def interpret_register(self) -&gt; int:\n\"\"\"Interpret register as signed integer value.\n\n        Checks if the most significant bit (bit 15) is set to determine\n        if the value is negative, then applies two's complement conversion\n        and coefficient scaling.\n\n        Returns:\n            The scaled signed integer value.\n        \"\"\"\n        if self.raw_data &amp; 32768 == 32768:\n            signed_number = self.raw_data - 65536\n            return signed_number / self._variable_confs.coefficient\n        return int(self.coeff_value(flt=True))\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.StandardIntVariableSigned.interpret_register","title":"<code>interpret_register() -&gt; int</code>","text":"<p>Interpret register as signed integer value.</p> <p>Checks if the most significant bit (bit 15) is set to determine if the value is negative, then applies two's complement conversion and coefficient scaling.</p> <p>Returns:</p> Type Description <code>int</code> <p>The scaled signed integer value.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; int:\n\"\"\"Interpret register as signed integer value.\n\n    Checks if the most significant bit (bit 15) is set to determine\n    if the value is negative, then applies two's complement conversion\n    and coefficient scaling.\n\n    Returns:\n        The scaled signed integer value.\n    \"\"\"\n    if self.raw_data &amp; 32768 == 32768:\n        signed_number = self.raw_data - 65536\n        return signed_number / self._variable_confs.coefficient\n    return int(self.coeff_value(flt=True))\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#standardstrvariablemapping","title":"StandardStrVariableMapping","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for mapping integer values to string representations.</p> <p>Applies coefficient scaling to the register value and maps the resulting integer to a string representation using the configured mapping dictionary. Commonly used for status codes and enumerated values.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass StandardStrVariableMapping(EpeverVariableObject):\n\"\"\"Variable object for mapping integer values to string representations.\n\n    Applies coefficient scaling to the register value and maps the resulting\n    integer to a string representation using the configured mapping dictionary.\n    Commonly used for status codes and enumerated values.\n    \"\"\"\n\n    def interpret_register(self) -&gt; str:\n\"\"\"Interpret register by mapping scaled integer value to string.\n\n        Returns:\n            The mapped string value from the configuration, or \"Unknown (value)\"\n            if no mapping is configured or the value is not in the mapping.\n        \"\"\"\n        if not self._variable_confs.mapping:\n            logger.warning(f\"Missing mapping conf for {self.variable_name}\")\n            return f\"Unknown ({self.coeff_value()})\"\n\n        return self._variable_confs.mapping.get(\n            int(self.coeff_value()), f\"Unknown ({self.coeff_value()})\"\n        )\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.StandardStrVariableMapping.interpret_register","title":"<code>interpret_register() -&gt; str</code>","text":"<p>Interpret register by mapping scaled integer value to string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The mapped string value from the configuration, or \"Unknown (value)\"</p> <code>str</code> <p>if no mapping is configured or the value is not in the mapping.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; str:\n\"\"\"Interpret register by mapping scaled integer value to string.\n\n    Returns:\n        The mapped string value from the configuration, or \"Unknown (value)\"\n        if no mapping is configured or the value is not in the mapping.\n    \"\"\"\n    if not self._variable_confs.mapping:\n        logger.warning(f\"Missing mapping conf for {self.variable_name}\")\n        return f\"Unknown ({self.coeff_value()})\"\n\n    return self._variable_confs.mapping.get(\n        int(self.coeff_value()), f\"Unknown ({self.coeff_value()})\"\n    )\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#errorvariable","title":"ErrorVariable","text":"<p>               Bases: <code>EpeverVariableObject</code></p> <p>Variable object for error code values.</p> <p>Interprets register data as an error code integer value by applying the coefficient scaling. Used specifically for error status registers.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>@register_variable_objects\nclass ErrorVariable(EpeverVariableObject):\n\"\"\"Variable object for error code values.\n\n    Interprets register data as an error code integer value by applying\n    the coefficient scaling. Used specifically for error status registers.\n    \"\"\"\n\n    def interpret_register(self) -&gt; int:\n\"\"\"Interpret register as error code integer value.\n\n        Returns:\n            The scaled integer error code value.\n        \"\"\"\n        return int(self.coeff_value())\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.ErrorVariable.interpret_register","title":"<code>interpret_register() -&gt; int</code>","text":"<p>Interpret register as error code integer value.</p> <p>Returns:</p> Type Description <code>int</code> <p>The scaled integer error code value.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def interpret_register(self) -&gt; int:\n\"\"\"Interpret register as error code integer value.\n\n    Returns:\n        The scaled integer error code value.\n    \"\"\"\n    return int(self.coeff_value())\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#functions","title":"Functions","text":""},{"location":"api/external_api/epever/epever_objects/#register_variable_objects","title":"register_variable_objects","text":"<p>Register an EpeverVariableObject subclass to the factory registry.</p> <p>This decorator registers a variable object class to the VARIABLE_FACTORY dictionary, making it available for instantiation via <code>get_variable_cls()</code>. The class is registered under its class name.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[EpeverVariableObject]</code> <p>The EpeverVariableObject subclass to register.</p> required <p>Returns:</p> Type Description <p>The class unchanged, allowing it to be used as a decorator.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def register_variable_objects(cls: type[\"EpeverVariableObject\"]):\n\"\"\"Register an EpeverVariableObject subclass to the factory registry.\n\n    This decorator registers a variable object class to the VARIABLE_FACTORY\n    dictionary, making it available for instantiation via `get_variable_cls()`.\n    The class is registered under its class name.\n\n    Args:\n        cls: The EpeverVariableObject subclass to register.\n\n    Returns:\n        The class unchanged, allowing it to be used as a decorator.\n    \"\"\"\n    logger.warning(f\"Registering {cls} to variable factory\")\n    VARIABLE_FACTORY[cls.__name__] = cls\n    return cls\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#get_variable_cls","title":"get_variable_cls","text":"<p>Retrieve a variable object class from the factory registry.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The name of the variable class to retrieve.</p> required <p>Returns:</p> Type Description <code>type[EpeverVariableObject] | None</code> <p>The registered EpeverVariableObject subclass if found, None otherwise.</p> Source code in <code>external_api/epever/epever_objects.py</code> <pre><code>def get_variable_cls(variable_name: str) -&gt; type[\"EpeverVariableObject\"] | None:\n\"\"\"Retrieve a variable object class from the factory registry.\n\n    Args:\n        variable_name: The name of the variable class to retrieve.\n\n    Returns:\n        The registered EpeverVariableObject subclass if found, None otherwise.\n    \"\"\"\n    cls = VARIABLE_FACTORY.get(variable_name, None)\n    if not cls:\n        logger.warning(f\"could not find {variable_name} in {VARIABLE_FACTORY=}\")\n    return cls\n</code></pre>"},{"location":"api/external_api/epever/epever_objects/#variables","title":"Variables","text":""},{"location":"api/external_api/epever/epever_objects/#external_api.epever.epever_objects.VARIABLE_FACTORY","title":"<code>external_api.epever.epever_objects.VARIABLE_FACTORY: dict[str, type[EpeverVariableObject]] = {}</code>  <code>module-attribute</code>","text":"<p>Factory registry for EpeverVariableObject implementations.</p> <p>Maps variable class names to their corresponding EpeverVariableObject subclass implementations. This dictionary is populated by the <code>register_variable_objects</code> decorator.</p>"},{"location":"api/programs/data_sync/data_sync/","title":"programs.data_sync.data_sync","text":""},{"location":"api/programs/data_sync/data_sync/#classes","title":"Classes","text":""},{"location":"api/programs/data_sync/data_sync/#basedatasync","title":"BaseDataSync","text":"<p>Base class for all Data Sync implementations</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>class BaseDataSync:\n\"\"\"Base class for all Data Sync implementations\"\"\"\n\n    fieldNames: list = [\"file_path\", \"seek_position\", \"last_modified\", \"file_size\"]\n\n    def __init__(self):\n        self.config = config()  # type: ignore\n        self.data_dir = self.config.data_dir\n        self.state_path = self.config.state_path\n        self.files_dict: dict[Path, File] = {}\n        self.active: bool = True\n\n    def fetch_all_files(self) -&gt; list[Path]:\n\"\"\"\n        Fetch all Files\n\n        returns:\n            list[Path]: sorted(datetime wise) list of all CSV file paths in the data directory\n        \"\"\"\n        all_files = []\n        for dirpath, _, files in os.walk(self.data_dir, topdown=True):\n            for file in files:\n                if file.endswith(\".csv\"):\n                    all_files.append(Path(os.path.join(dirpath, file)))\n        all_files = all_files.sort()\n        return all_files\n\n    def extract_data_from_filepath(self, file_path: Path) -&gt; FileInfo | None:\n\"\"\"\n        Helper function to extract device information from the filepath. Will return None\n        if unable to exract the relevent data.\n\n        The data directory is intended to be the root, and be arranged in one of two ways:\n        1) data/device_type/device_id/data_file.csv\n        2) data/site_id/device_type/device_id/data_file.csv\n\n        The latter is when this is run on a server where the files have been synced.\n        For the former, the site_id will be taken from the program config instead.\n\n        There are different kinds of files:\n\n        1) The base file is the general data file, which\n        has the format: YYYY-MM-DD.csv. This contains data in the standard format:\n        [timestamp, variable_name, raw_data, unit, processed_data]\n\n        2) Status files have the format: YYYY-MM-DD.status.csv. This contains data in the format:\n        [status_name, status, description, timestamp]\n        \"\"\"\n\n        site_id, device_type, device_id, file_type = None, None, None, None\n        info = None\n\n        try:\n            parts = list(file_path.parts)\n\n            fn = parts.pop()\n            if fnmatch.fnmatch(fn, \"*status.csv\"):\n                file_type = FileTypes.STATUS\n            elif fnmatch.fnmatch(fn, \"*.csv\"):\n                file_type = FileTypes.DATA\n            else:\n                logger.warning(f\"Unknown file type: {fn}\")\n                return None\n\n            device_id = parts.pop()\n            device_type = parts.pop()\n            if len(parts) &gt; 0:\n                site_id = parts.pop()\n            else:\n                site_id = self.config.site_id\n\n            info = FileInfo(\n                site_id=site_id,\n                device_type=device_type,\n                device_id=device_id,\n                file_type=file_type,\n            )\n        except Exception as e:\n            logger.exception(f\"Failed to extract data from filepath {file_path}: {e}\")\n\n        return info\n\n    def update_state_dict(self, delete_missing=False):\n\"\"\"Updates the state dictionary with the current file states\"\"\"\n        all_files = self.fetch_all_files()\n        old_files = set(self.files_dict.keys())\n        new, unchanged, modified = 0, 0, 0\n\n        for file_path in all_files:\n            stat = file_path.stat()\n            if file_path not in self.files_dict:\n                file = File(\n                    file_path=file_path,\n                    seek_position=0,\n                    last_modified=int(stat.st_mtime),\n                    file_size=stat.st_size,\n                )\n                self.files_dict[file_path] = file\n                logger.info(f\"New file found: {file=}\")\n                new += 1\n            else:\n                file = self.files_dict[file_path]\n                old_files.remove(file_path)\n                if (\n                    file.last_modified == int(stat.st_mtime)\n                    and file.file_size == stat.st_size\n                ):\n                    logger.debug(f\"File unchanged: {file=}\")\n                    unchanged += 1\n                    continue\n                file.last_modified = int(stat.st_mtime)\n                file.file_size = stat.st_size\n                logger.info(f\"File updated: {file=}\")\n                modified += 1\n\n        if delete_missing:\n            for file_path in old_files:\n                del self.files_dict[file_path]\n\n        logger.info(\n            f\"Updated state dictionary: {len(all_files)} files scanned, {new} new files, {modified} changed files, {unchanged} unchanged files and {len(old_files)} removed files\"\n        )\n\n    def read_state(self) -&gt; None:\n\"\"\"Called when creating the FileDriver. Will load the file state from disk\"\"\"\n        logger.info(\"Reading File State\")\n        if not self.state_path.exists():\n            logger.info(\n                f\"State file {self.state_path} does not exist. Creating a new one.\"\n            )\n            self.state_path.touch()\n\n        with self.state_path.open() as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                file = Path(row[\"file_path\"])\n                try:\n                    file_obj = File(**row)  # type: ignore\n                except Exception as e:\n                    logger.warning(\n                        f\"Unable to parse file state for {file}: {row} ({e})\"\n                    )\n                    file_obj = File(file_path=file)\n                self.files_dict[file] = file_obj\n\n\n    def save_state(self) -&gt; None:\n\"\"\"Called every poll interval. Will save any file specific state to disk\"\"\"\n        logger.debug(\"Trying to save file state...\")\n        with self.state_path.open(\"w\") as f:\n            writer = csv.DictWriter(\n                f, fieldnames=self.fieldNames, extrasaction=\"ignore\"\n            )\n            writer.writeheader()\n            for file_path, file_obj in self.files_dict.items():\n                writer.writerow(file_obj.model_dump(mode=\"json\"))\n\n        logger.debug(\"Finished saving state\")\n\n    def update_file_seek(self, file_path: Path, seek: int) -&gt; None:\n\"\"\"Updates the seek position for a file\"\"\"\n        stat = file_path.stat()\n        if file_path in self.files_dict:\n            file_obj: File = self.files_dict[file_path]\n            file_obj.seek_position = seek\n            file_obj.last_modified = int(stat.st_mtime)\n            file_obj.file_size = stat.st_size\n        else:\n            self.files_dict[file_path] = File(\n                file_path=file_path,\n                seek_position=seek,\n                last_modified=int(stat.st_mtime),\n                file_size=stat.st_size,\n            )\n\n    def read_data(self, file: Path, start_seek: int) -&gt; tuple[list[Variable], int]:\n\"\"\"Reads Data from CSV data file\"\"\"\n\n        with file.open() as f:\n            f.seek(start_seek)\n            reader = csv.DictReader(f, fieldnames=VAR_FILE_FIELD_NAMES)\n            data = []\n            for row in reader:\n                try:\n                    if row[\"unit\"] == \"None\":\n                        variable = StringVariable(**row)  # type: ignore\n                    elif row[\"variable_name\"] in [\n                        \"/utility/energy/flow\",\n                        \"/ac/input_mode\",\n                        \"/conf/pv/oc_voltage\",\n                    ]:\n                        continue\n                    else:\n                        variable = FloatVariable(**row)  # type:ignore\n                    # variable = Variable(*row) #type: ignore\n                    data.append(variable)\n                except Exception as e:\n                    logger.error(f\"Error parsing row {row}: {e}\")\n                    continue\n            logger.info(f\"Finished reading data from {file}\")\n            # Return the current file position\n            current_position = f.tell()\n            return data, current_position\n\n    def read_status(self, file: Path, start_seek: int) -&gt; tuple[list[Status], int]:\n\"\"\"Reads Status from CSV status file\"\"\"\n\n        with file.open() as f:\n            f.seek(start_seek)\n            reader = csv.DictReader(f, fieldnames=STATUS_FILE_FIELD_NAMES)\n            data = []\n            for row in reader:\n                try:\n                    status = Status(**row)  # type: ignore\n                    data.append(status)\n                except Exception as e:\n                    logger.error(f\"Error parsing row {row}: {e}\")\n                    continue\n            logger.info(f\"Finished reading status from {file}\")\n            # Return the current file position\n            current_position = f.tell()\n            return data, current_position\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.extract_data_from_filepath","title":"<code>extract_data_from_filepath(file_path: Path) -&gt; FileInfo | None</code>","text":"<p>Helper function to extract device information from the filepath. Will return None if unable to exract the relevent data.</p> <p>The data directory is intended to be the root, and be arranged in one of two ways: 1) data/device_type/device_id/data_file.csv 2) data/site_id/device_type/device_id/data_file.csv</p> <p>The latter is when this is run on a server where the files have been synced. For the former, the site_id will be taken from the program config instead.</p> <p>There are different kinds of files:</p> <p>1) The base file is the general data file, which has the format: YYYY-MM-DD.csv. This contains data in the standard format: [timestamp, variable_name, raw_data, unit, processed_data]</p> <p>2) Status files have the format: YYYY-MM-DD.status.csv. This contains data in the format: [status_name, status, description, timestamp]</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def extract_data_from_filepath(self, file_path: Path) -&gt; FileInfo | None:\n\"\"\"\n    Helper function to extract device information from the filepath. Will return None\n    if unable to exract the relevent data.\n\n    The data directory is intended to be the root, and be arranged in one of two ways:\n    1) data/device_type/device_id/data_file.csv\n    2) data/site_id/device_type/device_id/data_file.csv\n\n    The latter is when this is run on a server where the files have been synced.\n    For the former, the site_id will be taken from the program config instead.\n\n    There are different kinds of files:\n\n    1) The base file is the general data file, which\n    has the format: YYYY-MM-DD.csv. This contains data in the standard format:\n    [timestamp, variable_name, raw_data, unit, processed_data]\n\n    2) Status files have the format: YYYY-MM-DD.status.csv. This contains data in the format:\n    [status_name, status, description, timestamp]\n    \"\"\"\n\n    site_id, device_type, device_id, file_type = None, None, None, None\n    info = None\n\n    try:\n        parts = list(file_path.parts)\n\n        fn = parts.pop()\n        if fnmatch.fnmatch(fn, \"*status.csv\"):\n            file_type = FileTypes.STATUS\n        elif fnmatch.fnmatch(fn, \"*.csv\"):\n            file_type = FileTypes.DATA\n        else:\n            logger.warning(f\"Unknown file type: {fn}\")\n            return None\n\n        device_id = parts.pop()\n        device_type = parts.pop()\n        if len(parts) &gt; 0:\n            site_id = parts.pop()\n        else:\n            site_id = self.config.site_id\n\n        info = FileInfo(\n            site_id=site_id,\n            device_type=device_type,\n            device_id=device_id,\n            file_type=file_type,\n        )\n    except Exception as e:\n        logger.exception(f\"Failed to extract data from filepath {file_path}: {e}\")\n\n    return info\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.fetch_all_files","title":"<code>fetch_all_files() -&gt; list[Path]</code>","text":"<p>Fetch all Files</p> <p>Returns:</p> Type Description <code>list[Path]</code> <p>list[Path]: sorted(datetime wise) list of all CSV file paths in the data directory</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def fetch_all_files(self) -&gt; list[Path]:\n\"\"\"\n    Fetch all Files\n\n    returns:\n        list[Path]: sorted(datetime wise) list of all CSV file paths in the data directory\n    \"\"\"\n    all_files = []\n    for dirpath, _, files in os.walk(self.data_dir, topdown=True):\n        for file in files:\n            if file.endswith(\".csv\"):\n                all_files.append(Path(os.path.join(dirpath, file)))\n    all_files = all_files.sort()\n    return all_files\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.read_data","title":"<code>read_data(file: Path, start_seek: int) -&gt; tuple[list[Variable], int]</code>","text":"<p>Reads Data from CSV data file</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def read_data(self, file: Path, start_seek: int) -&gt; tuple[list[Variable], int]:\n\"\"\"Reads Data from CSV data file\"\"\"\n\n    with file.open() as f:\n        f.seek(start_seek)\n        reader = csv.DictReader(f, fieldnames=VAR_FILE_FIELD_NAMES)\n        data = []\n        for row in reader:\n            try:\n                if row[\"unit\"] == \"None\":\n                    variable = StringVariable(**row)  # type: ignore\n                elif row[\"variable_name\"] in [\n                    \"/utility/energy/flow\",\n                    \"/ac/input_mode\",\n                    \"/conf/pv/oc_voltage\",\n                ]:\n                    continue\n                else:\n                    variable = FloatVariable(**row)  # type:ignore\n                # variable = Variable(*row) #type: ignore\n                data.append(variable)\n            except Exception as e:\n                logger.error(f\"Error parsing row {row}: {e}\")\n                continue\n        logger.info(f\"Finished reading data from {file}\")\n        # Return the current file position\n        current_position = f.tell()\n        return data, current_position\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.read_state","title":"<code>read_state() -&gt; None</code>","text":"<p>Called when creating the FileDriver. Will load the file state from disk</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def read_state(self) -&gt; None:\n\"\"\"Called when creating the FileDriver. Will load the file state from disk\"\"\"\n    logger.info(\"Reading File State\")\n    if not self.state_path.exists():\n        logger.info(\n            f\"State file {self.state_path} does not exist. Creating a new one.\"\n        )\n        self.state_path.touch()\n\n    with self.state_path.open() as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            file = Path(row[\"file_path\"])\n            try:\n                file_obj = File(**row)  # type: ignore\n            except Exception as e:\n                logger.warning(\n                    f\"Unable to parse file state for {file}: {row} ({e})\"\n                )\n                file_obj = File(file_path=file)\n            self.files_dict[file] = file_obj\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.read_status","title":"<code>read_status(file: Path, start_seek: int) -&gt; tuple[list[Status], int]</code>","text":"<p>Reads Status from CSV status file</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def read_status(self, file: Path, start_seek: int) -&gt; tuple[list[Status], int]:\n\"\"\"Reads Status from CSV status file\"\"\"\n\n    with file.open() as f:\n        f.seek(start_seek)\n        reader = csv.DictReader(f, fieldnames=STATUS_FILE_FIELD_NAMES)\n        data = []\n        for row in reader:\n            try:\n                status = Status(**row)  # type: ignore\n                data.append(status)\n            except Exception as e:\n                logger.error(f\"Error parsing row {row}: {e}\")\n                continue\n        logger.info(f\"Finished reading status from {file}\")\n        # Return the current file position\n        current_position = f.tell()\n        return data, current_position\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.save_state","title":"<code>save_state() -&gt; None</code>","text":"<p>Called every poll interval. Will save any file specific state to disk</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def save_state(self) -&gt; None:\n\"\"\"Called every poll interval. Will save any file specific state to disk\"\"\"\n    logger.debug(\"Trying to save file state...\")\n    with self.state_path.open(\"w\") as f:\n        writer = csv.DictWriter(\n            f, fieldnames=self.fieldNames, extrasaction=\"ignore\"\n        )\n        writer.writeheader()\n        for file_path, file_obj in self.files_dict.items():\n            writer.writerow(file_obj.model_dump(mode=\"json\"))\n\n    logger.debug(\"Finished saving state\")\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.update_file_seek","title":"<code>update_file_seek(file_path: Path, seek: int) -&gt; None</code>","text":"<p>Updates the seek position for a file</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def update_file_seek(self, file_path: Path, seek: int) -&gt; None:\n\"\"\"Updates the seek position for a file\"\"\"\n    stat = file_path.stat()\n    if file_path in self.files_dict:\n        file_obj: File = self.files_dict[file_path]\n        file_obj.seek_position = seek\n        file_obj.last_modified = int(stat.st_mtime)\n        file_obj.file_size = stat.st_size\n    else:\n        self.files_dict[file_path] = File(\n            file_path=file_path,\n            seek_position=seek,\n            last_modified=int(stat.st_mtime),\n            file_size=stat.st_size,\n        )\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.BaseDataSync.update_state_dict","title":"<code>update_state_dict(delete_missing=False)</code>","text":"<p>Updates the state dictionary with the current file states</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def update_state_dict(self, delete_missing=False):\n\"\"\"Updates the state dictionary with the current file states\"\"\"\n    all_files = self.fetch_all_files()\n    old_files = set(self.files_dict.keys())\n    new, unchanged, modified = 0, 0, 0\n\n    for file_path in all_files:\n        stat = file_path.stat()\n        if file_path not in self.files_dict:\n            file = File(\n                file_path=file_path,\n                seek_position=0,\n                last_modified=int(stat.st_mtime),\n                file_size=stat.st_size,\n            )\n            self.files_dict[file_path] = file\n            logger.info(f\"New file found: {file=}\")\n            new += 1\n        else:\n            file = self.files_dict[file_path]\n            old_files.remove(file_path)\n            if (\n                file.last_modified == int(stat.st_mtime)\n                and file.file_size == stat.st_size\n            ):\n                logger.debug(f\"File unchanged: {file=}\")\n                unchanged += 1\n                continue\n            file.last_modified = int(stat.st_mtime)\n            file.file_size = stat.st_size\n            logger.info(f\"File updated: {file=}\")\n            modified += 1\n\n    if delete_missing:\n        for file_path in old_files:\n            del self.files_dict[file_path]\n\n    logger.info(\n        f\"Updated state dictionary: {len(all_files)} files scanned, {new} new files, {modified} changed files, {unchanged} unchanged files and {len(old_files)} removed files\"\n    )\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#influxdatasync","title":"InfluxDataSync","text":"<p>               Bases: <code>BaseDataSync</code></p> <p>InfluxDB Data Sync Implementation for both Variables and Status</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>class InfluxDataSync(BaseDataSync):\n\"\"\"InfluxDB Data Sync Implementation for both Variables and Status\"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def build_variable_payload(self, data: list[Variable], info: FileInfo) -&gt; str:\n\"\"\"Builds the payload for variable data in InfluxDB line protocol format\"\"\"\n        payload = list()\n        for variable in data:\n            line = list()\n            try:\n                # variable.timestamp is already a datetime object. Leave as seconds\n                timestamp_s = int(variable.timestamp.timestamp())\n            except Exception as e:\n                logger.error(\n                    f\"Error parsing existing timestamp {variable.timestamp}: {e}\"\n                )\n                # Skip this variable if timestamp can't be parsed\n                continue\n\n            match variable:\n                case FloatVariable():\n                    var = f\"float_value={round(variable.processed_data, 2)}\"\n                case StringVariable():\n                    var = f'string_value=\"{variable.processed_data}\"'\n                case _:\n                    logger.error(f\"Unknown variable type: {data}\")\n                    continue\n\n            line = [\n                f\"{self.config.influxdb.variable_table_id},\",\n                f\"site_id={info.site_id},\",\n                f\"device_id={info.device_id},\",\n                f\"device_type={info.device_type},\",\n                f'variable_name={(variable.variable_name[1:]).replace(\"/\", \"-\")}',\n                \" \",\n                f\"{var},\",\n                f'unit=\"{variable.unit}\"',\n                \" \",\n                f\"{timestamp_s}\",\n                \"\\n\",\n            ]\n            payload.append(\"\".join(line))\n\n        return \"\".join(payload).strip()\n\n    def build_status_payload(self, data: list[Status], info: FileInfo) -&gt; str:\n\"\"\"Builds the payload for status data in InfluxDB line protocol format\"\"\"\n        payload = list()\n        for status in data:\n            line = list()\n            try:\n                # variable.timestamp is already a datetime object. Leave as seconds\n                timestamp_s = int(status.timestamp.timestamp())\n            except Exception as e:\n                logger.error(\n                    f\"Error parsing existing timestamp {status.timestamp}: {e}\"\n                )\n                # Skip this variable if timestamp can't be parsed\n                continue\n\n            line = [\n                f'{self.config.influxdb.status_table_id},',\n                f'site_id={info.site_id},',\n                f'device_id={info.device_id},',\n                f'device_type={info.device_type},',\n                f'variable_name={(status.variable_name[1:]).replace(\"/\", \"-\").replace(\" \", \"_\")}',\n                ' ',\n                f'status=\"{status.status}\",',\n                f'description=\"{status.description}\"',\n                ' ',\n                f'{timestamp_s}',\n                '\\n'\n            ]\n            payload.append(\"\".join(line))\n\n        return \"\".join(payload).strip()\n\n    async def post_data(self, data: str):\n\"\"\"Posts data to InfluxDB\"\"\"\n        if not self.config.influxdb.token:\n            logger.error(\"InfluxDB token is not configured. Please set DATA_SYNC_INFLUXDB__TOKEN environment variable or add it to .env file.\")\n            raise ValueError(\"InfluxDB token is required but not configured\")\n        url = f\"{self.config.influxdb.host}?precision={self.config.influxdb.precision}&amp;db={self.config.influxdb.db}\"\n        headers = {\n            \"Content-Type\": \"text/plain\",\n            \"Authorization\": f\"Bearer {self.config.influxdb.token}\",\n        }\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.post(\n                    url, data=data, headers=headers, timeout=60\n                ) as resp:\n                    logger.debug(\"Posting Data to InfluxDB Server\")\n                    if resp.status != 204:\n                        error_text = await resp.text()\n                        logger.error(f\"Unable to post data to InfluxDB with status code: {resp.status} and error: {error_text}\")\n                    logger.info(f\"Data posted successfully with status {resp.status}\")\n                    return resp.status\n        except Exception as e:\n            logger.error(f\"Failed to post data: {e}\")\n            raise\n\n\n    async def sync_files(self, post=True):\n\"\"\"\n        Unified sync for both variable and status files.\n        Selects the reader and payload builder based on the file_type via a match statement,\n        performs shared read/build/post/update_seek logic to avoid duplication.\n        \"\"\"\n        logger.info(f\"Starting file sync at {datetime.now()}\")\n\n        for file, file_obj in self.files_dict.items():\n            if file_obj.seek_position == file_obj.file_size:\n                logger.debug(f\"Skipping {file} as it is fully synced\")\n                continue\n\n            info = self.extract_data_from_filepath(file)\n            if not info:\n                logger.info(f\"Skipping {file} as it is not a valid format\")\n                continue\n\n            # hacky fix to stop syncing an old variable format. Marked for removal in next update\n            if info.device_type == \"epever_hybrid_inverter\":\n                continue\n\n            # Choose reader and builder based on file type\n            match info.file_type:\n                case FileTypes.DATA:\n                    data, current_seek_position = self.read_data(\n                        file=file, start_seek=file_obj.seek_position\n                    )\n                    payload = self.build_variable_payload(data, info)\n                case FileTypes.STATUS:\n                    data, current_seek_position = self.read_status(\n                        file=file, start_seek=file_obj.seek_position\n                    )\n                    payload = self.build_status_payload(data, info)\n                case _:\n                    payload = None\n                    logger.debug(f\"Unknown file type for {file}, skipping\")\n                    continue\n\n            if not payload:\n                logger.debug(f\"No payload built for {file}\")\n                continue\n\n            # Post if requested\n            if post:\n                try:\n                    response = await self.post_data(payload)\n                    if response == 204:\n                        logger.info(f\"Successfully posted {info.file_type} data from {file}\")\n                        self.update_file_seek(file, current_seek_position)\n                    else:\n                        logger.error(f\"Failed to post {info.file_type} data from {file}\")\n                except Exception as e:\n                    logger.error(f\"DataSyncError while posting {info.file_type} data from {file}: {e}\")\n                    continue\n\n        logger.info(f\"File sync completed at {datetime.now()}\")\n\n    async def sync(self, post=True):\n\"\"\"\n        Full sync cycle - syncs both variables and status using unified logic\n        \"\"\"\n        logger.info(f\"Starting full sync cycle at {datetime.now()}\")\n        self.read_state()\n        self.update_state_dict()\n\n        await self.sync_files(post=post)\n\n        self.save_state()\n        logger.info(f\"Full sync cycle completed at {datetime.now()}\")\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.InfluxDataSync.build_status_payload","title":"<code>build_status_payload(data: list[Status], info: FileInfo) -&gt; str</code>","text":"<p>Builds the payload for status data in InfluxDB line protocol format</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def build_status_payload(self, data: list[Status], info: FileInfo) -&gt; str:\n\"\"\"Builds the payload for status data in InfluxDB line protocol format\"\"\"\n    payload = list()\n    for status in data:\n        line = list()\n        try:\n            # variable.timestamp is already a datetime object. Leave as seconds\n            timestamp_s = int(status.timestamp.timestamp())\n        except Exception as e:\n            logger.error(\n                f\"Error parsing existing timestamp {status.timestamp}: {e}\"\n            )\n            # Skip this variable if timestamp can't be parsed\n            continue\n\n        line = [\n            f'{self.config.influxdb.status_table_id},',\n            f'site_id={info.site_id},',\n            f'device_id={info.device_id},',\n            f'device_type={info.device_type},',\n            f'variable_name={(status.variable_name[1:]).replace(\"/\", \"-\").replace(\" \", \"_\")}',\n            ' ',\n            f'status=\"{status.status}\",',\n            f'description=\"{status.description}\"',\n            ' ',\n            f'{timestamp_s}',\n            '\\n'\n        ]\n        payload.append(\"\".join(line))\n\n    return \"\".join(payload).strip()\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.InfluxDataSync.build_variable_payload","title":"<code>build_variable_payload(data: list[Variable], info: FileInfo) -&gt; str</code>","text":"<p>Builds the payload for variable data in InfluxDB line protocol format</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>def build_variable_payload(self, data: list[Variable], info: FileInfo) -&gt; str:\n\"\"\"Builds the payload for variable data in InfluxDB line protocol format\"\"\"\n    payload = list()\n    for variable in data:\n        line = list()\n        try:\n            # variable.timestamp is already a datetime object. Leave as seconds\n            timestamp_s = int(variable.timestamp.timestamp())\n        except Exception as e:\n            logger.error(\n                f\"Error parsing existing timestamp {variable.timestamp}: {e}\"\n            )\n            # Skip this variable if timestamp can't be parsed\n            continue\n\n        match variable:\n            case FloatVariable():\n                var = f\"float_value={round(variable.processed_data, 2)}\"\n            case StringVariable():\n                var = f'string_value=\"{variable.processed_data}\"'\n            case _:\n                logger.error(f\"Unknown variable type: {data}\")\n                continue\n\n        line = [\n            f\"{self.config.influxdb.variable_table_id},\",\n            f\"site_id={info.site_id},\",\n            f\"device_id={info.device_id},\",\n            f\"device_type={info.device_type},\",\n            f'variable_name={(variable.variable_name[1:]).replace(\"/\", \"-\")}',\n            \" \",\n            f\"{var},\",\n            f'unit=\"{variable.unit}\"',\n            \" \",\n            f\"{timestamp_s}\",\n            \"\\n\",\n        ]\n        payload.append(\"\".join(line))\n\n    return \"\".join(payload).strip()\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.InfluxDataSync.post_data","title":"<code>post_data(data: str)</code>  <code>async</code>","text":"<p>Posts data to InfluxDB</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>async def post_data(self, data: str):\n\"\"\"Posts data to InfluxDB\"\"\"\n    if not self.config.influxdb.token:\n        logger.error(\"InfluxDB token is not configured. Please set DATA_SYNC_INFLUXDB__TOKEN environment variable or add it to .env file.\")\n        raise ValueError(\"InfluxDB token is required but not configured\")\n    url = f\"{self.config.influxdb.host}?precision={self.config.influxdb.precision}&amp;db={self.config.influxdb.db}\"\n    headers = {\n        \"Content-Type\": \"text/plain\",\n        \"Authorization\": f\"Bearer {self.config.influxdb.token}\",\n    }\n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                url, data=data, headers=headers, timeout=60\n            ) as resp:\n                logger.debug(\"Posting Data to InfluxDB Server\")\n                if resp.status != 204:\n                    error_text = await resp.text()\n                    logger.error(f\"Unable to post data to InfluxDB with status code: {resp.status} and error: {error_text}\")\n                logger.info(f\"Data posted successfully with status {resp.status}\")\n                return resp.status\n    except Exception as e:\n        logger.error(f\"Failed to post data: {e}\")\n        raise\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.InfluxDataSync.sync","title":"<code>sync(post=True)</code>  <code>async</code>","text":"<p>Full sync cycle - syncs both variables and status using unified logic</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>async def sync(self, post=True):\n\"\"\"\n    Full sync cycle - syncs both variables and status using unified logic\n    \"\"\"\n    logger.info(f\"Starting full sync cycle at {datetime.now()}\")\n    self.read_state()\n    self.update_state_dict()\n\n    await self.sync_files(post=post)\n\n    self.save_state()\n    logger.info(f\"Full sync cycle completed at {datetime.now()}\")\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.InfluxDataSync.sync_files","title":"<code>sync_files(post=True)</code>  <code>async</code>","text":"<p>Unified sync for both variable and status files. Selects the reader and payload builder based on the file_type via a match statement, performs shared read/build/post/update_seek logic to avoid duplication.</p> Source code in <code>programs/data_sync/data_sync.py</code> <pre><code>async def sync_files(self, post=True):\n\"\"\"\n    Unified sync for both variable and status files.\n    Selects the reader and payload builder based on the file_type via a match statement,\n    performs shared read/build/post/update_seek logic to avoid duplication.\n    \"\"\"\n    logger.info(f\"Starting file sync at {datetime.now()}\")\n\n    for file, file_obj in self.files_dict.items():\n        if file_obj.seek_position == file_obj.file_size:\n            logger.debug(f\"Skipping {file} as it is fully synced\")\n            continue\n\n        info = self.extract_data_from_filepath(file)\n        if not info:\n            logger.info(f\"Skipping {file} as it is not a valid format\")\n            continue\n\n        # hacky fix to stop syncing an old variable format. Marked for removal in next update\n        if info.device_type == \"epever_hybrid_inverter\":\n            continue\n\n        # Choose reader and builder based on file type\n        match info.file_type:\n            case FileTypes.DATA:\n                data, current_seek_position = self.read_data(\n                    file=file, start_seek=file_obj.seek_position\n                )\n                payload = self.build_variable_payload(data, info)\n            case FileTypes.STATUS:\n                data, current_seek_position = self.read_status(\n                    file=file, start_seek=file_obj.seek_position\n                )\n                payload = self.build_status_payload(data, info)\n            case _:\n                payload = None\n                logger.debug(f\"Unknown file type for {file}, skipping\")\n                continue\n\n        if not payload:\n            logger.debug(f\"No payload built for {file}\")\n            continue\n\n        # Post if requested\n        if post:\n            try:\n                response = await self.post_data(payload)\n                if response == 204:\n                    logger.info(f\"Successfully posted {info.file_type} data from {file}\")\n                    self.update_file_seek(file, current_seek_position)\n                else:\n                    logger.error(f\"Failed to post {info.file_type} data from {file}\")\n            except Exception as e:\n                logger.error(f\"DataSyncError while posting {info.file_type} data from {file}: {e}\")\n                continue\n\n    logger.info(f\"File sync completed at {datetime.now()}\")\n</code></pre>"},{"location":"api/programs/data_sync/data_sync/#variables","title":"Variables","text":""},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.VAR_FILE_FIELD_NAMES","title":"<code>programs.data_sync.data_sync.VAR_FILE_FIELD_NAMES = ['timestamp', 'variable_name', 'raw_data', 'unit', 'processed_data']</code>  <code>module-attribute</code>","text":""},{"location":"api/programs/data_sync/data_sync/#programs.data_sync.data_sync.STATUS_FILE_FIELD_NAMES","title":"<code>programs.data_sync.data_sync.STATUS_FILE_FIELD_NAMES = ['timestamp', 'variable_name', 'status', 'description']</code>  <code>module-attribute</code>","text":""},{"location":"api/programs/data_sync/data_sync_settings/","title":"programs.data_sync.data_sync_settings","text":""},{"location":"api/programs/data_sync/data_sync_settings/#classes","title":"Classes","text":""},{"location":"api/programs/data_sync/data_sync_settings/#influxdbconfig","title":"InfluxDBConfig","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration settings for InfluxDB database connection and operations.</p> <p>This class defines all parameters required to connect to and write data to an InfluxDB instance, including authentication, database selection, and batch processing settings.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Authentication token for InfluxDB API access.</p> <code>host</code> <code>str</code> <p>InfluxDB server host URL (e.g., \"http://localhost:8086\").</p> <code>precision</code> <code>str</code> <p>Time precision for timestamps (e.g., \"s\" for seconds, \"ms\" for milliseconds, \"us\" for microseconds, \"ns\" for nanoseconds).</p> <code>db</code> <code>str</code> <p>Database name to write data to.</p> <code>variable_table_id</code> <code>str</code> <p>Measurement/table name for variable data points.</p> <code>status_table_id</code> <code>str</code> <p>Measurement/table name for status data points.</p> <code>batch_size</code> <code>int</code> <p>Number of data points to batch together before sending to InfluxDB.</p> Source code in <code>programs/data_sync/data_sync_settings.py</code> <pre><code>class InfluxDBConfig(BaseModel):\n\"\"\"Configuration settings for InfluxDB database connection and operations.\n\n    This class defines all parameters required to connect to and write data\n    to an InfluxDB instance, including authentication, database selection,\n    and batch processing settings.\n\n    Attributes:\n        token: Authentication token for InfluxDB API access.\n        host: InfluxDB server host URL (e.g., \"http://localhost:8086\").\n        precision: Time precision for timestamps (e.g., \"s\" for seconds,\n            \"ms\" for milliseconds, \"us\" for microseconds, \"ns\" for nanoseconds).\n        db: Database name to write data to.\n        variable_table_id: Measurement/table name for variable data points.\n        status_table_id: Measurement/table name for status data points.\n        batch_size: Number of data points to batch together before sending\n            to InfluxDB.\n    \"\"\"\n\n    token: str\n    host: str\n    precision: str\n    db: str\n    variable_table_id: str\n    status_table_id: str\n    batch_size: int\n</code></pre>"},{"location":"api/programs/data_sync/data_sync_settings/#config","title":"config","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Main configuration class for the data synchronization program.</p> <p>This class manages all configuration settings for the data sync program, including file paths, synchronization intervals, site identification, and InfluxDB connection settings. Configuration is loaded from multiple sources in priority order: initialization arguments, environment variables, .env file, YAML configuration files, and secret files.</p> <p>Configuration sources (in priority order):     1. Initialization arguments (highest priority)     2. Environment variables (prefixed with DATA_SYNC_)     3. .env file     4. YAML files (config.yml, then custom_config.yml)     5. Secret files (lowest priority)</p> <p>Attributes:</p> Name Type Description <code>data_dir</code> <code>Path</code> <p>Path to the directory containing CSV data files to sync.</p> <code>state_path</code> <code>Path</code> <p>Path to the state file that tracks synchronization progress.</p> <code>sync_interval</code> <code>int</code> <p>Time interval in seconds between successful synchronization attempts.</p> <code>sync_interval_on_failure</code> <code>int</code> <p>Time interval in seconds between synchronization attempts when the previous attempt failed.</p> <code>site_id</code> <code>str</code> <p>Unique identifier for the site/location where data is collected.</p> <code>influxdb</code> <code>InfluxDBConfig</code> <p>InfluxDBConfig instance containing database connection and operation settings.</p> Source code in <code>programs/data_sync/data_sync_settings.py</code> <pre><code>class config(BaseSettings):\n\"\"\"Main configuration class for the data synchronization program.\n\n    This class manages all configuration settings for the data sync program,\n    including file paths, synchronization intervals, site identification, and\n    InfluxDB connection settings. Configuration is loaded from multiple sources\n    in priority order: initialization arguments, environment variables, .env file,\n    YAML configuration files, and secret files.\n\n    Configuration sources (in priority order):\n        1. Initialization arguments (highest priority)\n        2. Environment variables (prefixed with DATA_SYNC_)\n        3. .env file\n        4. YAML files (config.yml, then custom_config.yml)\n        5. Secret files (lowest priority)\n\n    Attributes:\n        data_dir: Path to the directory containing CSV data files to sync.\n        state_path: Path to the state file that tracks synchronization progress.\n        sync_interval: Time interval in seconds between successful synchronization\n            attempts.\n        sync_interval_on_failure: Time interval in seconds between synchronization\n            attempts when the previous attempt failed.\n        site_id: Unique identifier for the site/location where data is collected.\n        influxdb: InfluxDBConfig instance containing database connection and\n            operation settings.\n    \"\"\"\n\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_ignore_empty=True,\n        extra=\"ignore\",\n        yaml_file=[\n            \"programs/data_sync/config.yml\",\n            \"programs/data_sync/custom_config.yml\",\n        ],\n        env_prefix=\"DATA_SYNC_\",\n        env_nested_delimiter=\"__\",\n    )\n    data_dir: Path\n    state_path: Path\n\n    sync_interval: int\n    sync_interval_on_failure: int\n    site_id: str\n    influxdb: InfluxDBConfig\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n\"\"\"Customize the settings sources priority order.\n\n        Configures the order of settings sources with YAML configuration\n        support. Sources are prioritized in the returned tuple order, with\n        earlier sources taking precedence over later ones.\n\n        Args:\n            settings_cls: The settings class type.\n            init_settings: Settings from initialization arguments (highest priority).\n            env_settings: Settings from environment variables.\n            dotenv_settings: Settings from .env file.\n            file_secret_settings: Settings from secret files (lowest priority).\n\n        Returns:\n            Tuple of settings sources in priority order, including YAML\n            configuration source between dotenv and file secret settings.\n        \"\"\"\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            YamlConfigSettingsSource(settings_cls),\n            file_secret_settings,\n        )\n</code></pre>"},{"location":"api/programs/data_sync/data_sync_settings/#programs.data_sync.data_sync_settings.config.settings_customise_sources","title":"<code>settings_customise_sources(settings_cls: type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -&gt; tuple[PydanticBaseSettingsSource, ...]</code>  <code>classmethod</code>","text":"<p>Customize the settings sources priority order.</p> <p>Configures the order of settings sources with YAML configuration support. Sources are prioritized in the returned tuple order, with earlier sources taking precedence over later ones.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>type[BaseSettings]</code> <p>The settings class type.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>Settings from initialization arguments (highest priority).</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>Settings from environment variables.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>Settings from .env file.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>Settings from secret files (lowest priority).</p> required <p>Returns:</p> Type Description <code>PydanticBaseSettingsSource</code> <p>Tuple of settings sources in priority order, including YAML</p> <code>...</code> <p>configuration source between dotenv and file secret settings.</p> Source code in <code>programs/data_sync/data_sync_settings.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n\"\"\"Customize the settings sources priority order.\n\n    Configures the order of settings sources with YAML configuration\n    support. Sources are prioritized in the returned tuple order, with\n    earlier sources taking precedence over later ones.\n\n    Args:\n        settings_cls: The settings class type.\n        init_settings: Settings from initialization arguments (highest priority).\n        env_settings: Settings from environment variables.\n        dotenv_settings: Settings from .env file.\n        file_secret_settings: Settings from secret files (lowest priority).\n\n    Returns:\n        Tuple of settings sources in priority order, including YAML\n        configuration source between dotenv and file secret settings.\n    \"\"\"\n    return (\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        YamlConfigSettingsSource(settings_cls),\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/programs/data_sync/schemas/","title":"programs.data_sync.schemas","text":""},{"location":"api/programs/data_sync/schemas/#classes","title":"Classes","text":""},{"location":"api/programs/data_sync/schemas/#filetypes","title":"FileTypes","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>class FileTypes(Enum):\n    DATA = \"data\"\n    STATUS = \"status\"\n</code></pre>"},{"location":"api/programs/data_sync/schemas/#file","title":"File","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>class File(BaseModel):\n    file_path: Path\n    seek_position: int = 0\n    last_modified: int = 0\n    file_size: int = 0\n    device_type: str = \"\"\n    device_id: str = \"\"\n    site_id: str = \"\"\n</code></pre>"},{"location":"api/programs/data_sync/schemas/#fileinfo","title":"FileInfo","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>class FileInfo(BaseModel):\n    site_id: str\n    device_type: str\n    device_id: str\n    file_type: FileTypes\n</code></pre>"},{"location":"api/programs/data_sync/schemas/#variable","title":"Variable","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>class Variable(BaseModel):\n    timestamp: datetime\n    variable_name: str\n    raw_data: int\n    unit: Optional[str] = None\n    processed_data: Optional[Any] = None\n</code></pre>"},{"location":"api/programs/data_sync/schemas/#stringvariable","title":"StringVariable","text":"<p>               Bases: <code>Variable</code></p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>class StringVariable(Variable):\n    processed_data: str\n    unit: str = \"-\"\n</code></pre>"},{"location":"api/programs/data_sync/schemas/#floatvariable","title":"FloatVariable","text":"<p>               Bases: <code>Variable</code></p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>class FloatVariable(Variable):\n    processed_data: float\n    unit: str\n\n    def serialize(self) -&gt; str:\n\"\"\"Serialize the Variable to a single line string protocol\"\"\"\n        return f\"\"\n</code></pre>"},{"location":"api/programs/data_sync/schemas/#programs.data_sync.schemas.FloatVariable.serialize","title":"<code>serialize() -&gt; str</code>","text":"<p>Serialize the Variable to a single line string protocol</p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>def serialize(self) -&gt; str:\n\"\"\"Serialize the Variable to a single line string protocol\"\"\"\n    return f\"\"\n</code></pre>"},{"location":"api/programs/data_sync/schemas/#status","title":"Status","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>programs/data_sync/schemas.py</code> <pre><code>class Status(BaseModel):\n    timestamp: datetime\n    variable_name: str\n    status: str\n    description: str\n</code></pre>"},{"location":"guides/setup/","title":"Quick Start Guide","text":"<p>This guide will help you set up the TGF Basestation program.</p>"},{"location":"guides/setup/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> <li>Docker (for containerized deployment)</li> </ul>"},{"location":"guides/setup/#monitoring-setup","title":"Monitoring Setup","text":""},{"location":"guides/setup/#development-setup","title":"Development Setup","text":""}]}